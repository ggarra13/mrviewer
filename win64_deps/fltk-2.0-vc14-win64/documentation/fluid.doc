// This file is for Doxygen input. It is not compiled.

using namespace fltk;

/*! \page fluid Programming with FLUID

This chapter shows how to use the Fast Light User-Interface Designer
("FLUID") to create your GUIs. FLUID is a graphical editor
that is used to produce FLTK source code.

FLUID edits and saves its state in <tt>.fl</tt> files.  These files are 
text, and you can (with care) edit them in a text editor, perhaps to 
get some special effects. 

FLUID can "compile" the <tt>.fl</tt> file into a <tt>.cxx</tt> and a
<tt>.h</tt> file.  The <tt>.cxx</tt> file defines all the objects from
the <tt>.fl</tt> file and the <tt>.h</tt> file declares all the global
ones.

A simple program can be made by putting all your code (including a <tt>
main()</tt> function) into the <tt>.fl</tt> file and thus making the <tt>.cxx</tt> file a 
single source file to compile.  Most programs are more complex than 
this, so you write other <tt>.cxx</tt> files that call the FLUID functions. 
 These <tt>.cxx</tt> files must <tt>#include</tt> the <tt>.h</tt> file or they can <tt>
#include</tt> the <tt>.cxx</tt> file so it still appears to be a single source 
file.

\image html fluid-org.gif

Normally the FLUID file defines one or more functions or classes which
output C++ code.  Each function defines a one or more FLTK 
windows, and all the widgets that go inside those windows. 

Widgets created by FLUID are either "named", "complex named" or 
"unnamed".  A named widget has a legal C++ variable identifier as its 
name (i.e. only alphanumeric and underscore).  In this case FLUID 
defines a global variable or class member that will point at the widget 
after the function defining it is called.  A complex named object has 
punctuation such as '.' or '-&gt;' or any other symbols in its name.  In 
this case FLUID assigns a pointer to the widget to the name, but does 
not attempt to declare it.  This can be used to get the widgets into 
structures.  An unnamed widget has a blank name and no pointer is stored. 

Widgets may either call a named callback function that you write in 
another source file, or you can supply a small piece of C++ source and 
FLUID will write a private callback function into the <tt>.cxx</tt> file. 

<h2>Running FLUID Under UNIX</h2>

To run FLUID under UNIX, type:
\code
fluid filename.fl &
\endcode
to edit the <tt>.fl</tt> file <tt>filename.fl</tt>.  If the file does
not exist you will get an error pop-up, but if you dismiss it you will
be editing a blank file of that name.  You can run FLUID without any
name, in which case you will be editing an unnamed blank setup (but
you can use save-as to write it to a file).

You can provide any of the standard FLTK switches before the filename: 
<PRE>
-display host:n.n
-geometry WxH+X+Y
-title windowtitle
-name classname
-iconic
-fg color
-bg color
-bg2 color
</PRE>
Changing the colors may be useful to see what your interface will look 
at if the user calls it with the same switches. 

If you don't go into the background (with 
'&amp;' then you will be able to abort FLUID by typing ^C on the terminal.
If there are any unsaved changes it will ask if you want to save them.

<h2>Running FLUID Under Microsoft Windows</h2>

To run FLUID under WIN32, double-click on the <I>FLUID.exe</I> file. 
You can also run FLUID from the Command Prompt window (FLUID always 
runs in the background under WIN32). 

<h2>Compiling <tt>.fl</tt> files</h2>

FLUID can also be called as a command-line "compiler" to create the 
<tt>.cxx</tt> and <tt>.h</tt> file from a <tt>.fl</tt> file.  To do this type: 
\code
fluid -c filename.fl
\endcode

This will read the <tt>filename.fl</tt> file and write <I>filename.cxx</I> and <I>
filename.h</I>. The directory will be stripped, so they are written to 
the current directory always.  If there are any errors reading or 
writing the files it will print the error and exit with a non-zero 
code.  In a makefile you can use a line like this:
\code
my_panels.h my_panels.cxx: my_panels.fl
	FLUID -c my_panels.fl
\endcode
 Some versions of make will accept rules like this to allow all <tt>.fl</tt> 
files found to be compiled: 
\code
.SUFFIXES: .fl .cxx .h
.fl.h .fl.cxx:
	FLUID -c $<
\endcode

<h2>A Short Tutorial</h2>

FLUID is an amazingly powerful little program. However, this power
comes at a price, as it is not always obvious how to accomplish seemingly
simple tasks with it. This tutorial will show you how to generate a
complete user interface class with FLUID that is used for the CubeView
program below.

\image html cubeview.gif

The window is of class CubeViewUI, and is completely generated by
FLUID, including class member functions. The central display of the
cube is a separate subclass of fltk::GlWindow called
CubeView. CubeViewUI manages CubeView using callbacks from the various
sliders and rollers to manipulate the viewing angle and zoom of
CubeView.

At the completion of this tutorial you will (hopefully) understand
how to:
- Use FLUID to create a complete user interface class, including
constructor and any member functions necessary.
- Use FLUID to set callbacks member functions of a custom widget
classes.
- Subclass a GlWindow to suit your purposes.

<h3>The CubeView Class</h3>

The CubeView class is a subclass of fltk::GlWindow. It has methods for
setting the zoom, the <i>x</i> and <i>y</i> pan, and the rotation angle
about the <i>x</i> and <i>y</i>axes.

You can safely skip this section as long as you realize the CubeView
is a sublass of <tt>fltk::GlWindow</tt> and will respond to calls from
CubeViewUI, generated by FLUID.

<h4>The CubeView Class Definition</h4>

Here is the CubeView class definition, as given by its header file
"test/CubeView.h":

\include CubeView.h

<h4>The CubeView Class Implementation</h4>

Here is the CubeView implementation. It is very similar to the
"cube" demo included with FLTK.

\include CubeView.cxx

<h3>The CubeViewUI Class</h3>

We will completely construct a window to display and control the
CubeView defined in the previous section using FLUID.

<h4>Defining the CubeViewUI Class</h4>

Once you have started FLUID, the first step in defining a class is to
create a new class within FLUID using the <b>New/Code/Class</b>
menu item. Name the class "CubeViewUI" and leave the
subclass blank. We do not need any inheritance for this
window. You should see the new class declaration in the FLUID
browser window.

\image html fluid1.gif

<h4>Adding the Class Constructor</h4>

Click on the CubeViewUI class in the FLUID window and add a new method
by selecting <b>New/Code/Function/Method.</b> The name of the
function will also be CubeViewUI. FLUID will understands that this will
be the constructor for the class and will generate the appropriate
code. Make sure you declare the constructor public.

Then add a window to the CubeViewUI class. Highlight the name of
the constructor in the FLUID browser window and click on
<b>New/Group/Window</b>. In a similar manner add the
following to the CubeViewUI constructor:
<ul>
<li>A horizontal roller named <tt>hrot</tt>
<li>A vertical roller named <tt>vrot</tt>
<li>A horizontal slider named <tt>xpan</tt>
<li>A vertical slider named <tt>ypan</tt>
<li>A horizontal value slider named <tt>zoom</tt>
</ul>
None of these additions need be public. And they shouldn't be
unless you plan to expose them as part of the interface for
CubeViewUI.

When you are finished you should have something like this:

\image html fluid2.gif

We will talk about the <tt>show()</tt> method that is highlighted
shortly.

<h4>Adding the CubeView Widget</h4>

What we have is nice, but does little to show our cube. We have already
defined the CubeView class and we would like to show it within the
CubeViewUI.

The CubeView class inherits the GlWindow class, which
is created in the same way as a InvisibleBox widget. Use
<b>New/Other/Widget</b> to add a square box to the main window.  This
will be no ordinary widget, however.

The Widget properties window will appear. The key to letting
CubeViewUI display CubeView is to enter CubeView in the "Class:" text
entry box. This tells FLUID to substitute "CubeView" in place of the
normal class name it would output.

In the "Extra Code:" field enter <tt>#include "CubeView.h"</tt> This
<tt>#include</tt> is important, as we have just included CubeView as a
member of CubeViewUI, so any public CubeView methods are now available
to CubeViewUI.

\image html fluid3.gif

<h4>Defining the Callbacks</h4>

Each of the widgets we defined before adding CubeView can have
callbacks that call CubeView methods. You can call an external
function or put in a short amount of code in the "Callback"
field of the widget panel. For example, the callback for the
<tt>ypan</tt> slider is:
\code
cube-&gt;pany(((fltk::Slider *)o)->value());
cube-&gt;redraw();
\endcode

We call <tt>cube-&gt;redraw()</tt> after changing the value to update
the CubeView window. CubeView could easily be modified to do this, but
it is nice to keep this exposed in the case where you may want to do
more than one view change only redrawing once saves a lot of time.

There is no reason no wait until after you have added CubeView to
enter these callbacks. FLUID assumes you are smart enough not to refer
to members or functions that don't exist.

<h4>Adding a Class Method</h4>

You can add class methods within FLUID that have nothing to do with the
GUI. As an example add a show function so that CubeViewUI can actually
appear on the screen.

Make sure the top level CubeViewUI is selected and select
<b>New/Code/Function/Method</b>. Just use the name
<tt>show()</tt>. We don't need a return value here, and since we will
not be adding any widgets to this method FLUID will assign it a return
type of <tt>void</tt>.

\image html fluid4.gif

Once the new method has been added, highlight its name and select
<b>New/Code/Code</b>. Enter the method's code in the code window.

<h3>Adding Constructor Initialization Code</h3>

If you need to add code to initialize class, for example setting
initial values of the horizontal and vertical angles in the
CubeView, you can simply highlight the Constructor and select
<b>New/Code/Code</b>. Add any required code.

<h3>Generating the Code</h3>

Now that we have completely defined the CubeViewUI, we have to generate
the code. There is one last trick to ensure this all works. Open the
preferences dialog from <b>Edit/Preferences</b>.

At the bottom of the preferences dialog box is the key: "Include
Header from Code". Select that option and set your desired file
extensions and you are in business. You can include the CubeViewUI.h
(or whatever extension you prefer) as you would any other C++ class.

<h2>FLUID Reference</h2>

<h3>The Widget Browser</h3>

The main window shows a menu bar and a scrolling browser of all the
defined widgets.  The name of the <tt>.fl</tt> file being edited is
shown in the window title.

The widgets are stored in a hierarchy.  You can open and close a 
level by clicking the "triangle" at the left of a widget. 
The leftmost widgets are the <I>parents</I>, and all the widgets
listed below them are their <I>children</I>.  Parents don't have to have
any children.

The top level of the hierarchy is composed of <I>functions</I> and
<I>classes</I>.  Each of these will produce a single C++ public
function or class in the output <tt>.cxx</tt> file.  Calling the function or
instantiating the class will create all of the child widgets. 

The second level of the hierarchy contains the <I>windows</I>.  Each of these 
produces an instance of class <tt>fltk::Window</tt>. 

Below that are either <I>widgets</I> (subclasses of Widget) or
<I>groups</I> of widgets (including other groups).  Plain groups are
for layout, navigation, and resize purposes. <I>Tab groups</I> provide
the well-known file-card tab interface.

Widgets are shown in the browser by either their <I>name</I> (such 
as "main_panel" in the example), or by their <I>type</I>
and <I>label</I> (such as "Button "the green""). 

You <I>select</I> widgets by clicking on their names, which highlights 
them (you can also select widgets from any displayed window).  You can 
select many widgets by dragging the mouse across them, or by using 
Shift+Click to toggle them on and off.  To select no widgets, click in 
the blank area under the last widget.  Note that hidden children may 
be selected even when there is no visual indication of this. 

You <I>open</I> widgets by double-clicking on them, or (to open several 
widgets you have picked) by typing the F1 key.  A control panel will appear
so you can change the widget(s).

<h3>Menu Items</h3>

The menu bar at the top is duplicated as a pop-up menu on any 
displayed window.  The shortcuts for all the menu items work in any 
window.  The menu items are: 

<h4>File/Open... (Alt+o)</h4>

Discards the current editing session and reads in a different
<tt>.fl</tt> file.  You are asked for confirmation if you have changed
the current file.

FLUID can also read <tt>.fd</tt> files produced by the Forms and
XForms "fdesign" programs. It is best to File/Merge them
instead of opening them. FLUID does not understand everything in a
<tt>.fd</tt> file, and will print a warning message on the controlling
terminal for all data it does not understand. You will probably need
to edit the resulting setup to fix these errors. Be careful not to
save the file without changing the name, as FLUID will write over the
<tt>.fd</tt> file with its own format, which fdesign cannot read! 

<h4>File/Save (Alt+s)</h4>
Writes the current data to the <tt>.fl</tt> file.  If the file is unnamed 
then FLUID will ask for a filename. 

<h4>File/Save As...(Alt+Shift+S)</h4>
Asks for a new filename and saves the file.

<h4>File/Merge... (Alt+i)</h4>
Inserts the contents of another <tt>.fl</tt> file, without changing the name of 
the current <tt>.fl</tt> file.  All the functions (even if they have the same 
names as the current ones) are added, and you will have to use cut/paste to 
put the widgets where you want. 

<h4>File/Write Code (Alt+Shift+C)</h4>
"Compiles" the data into a <tt>.cxx</tt> and <tt>.h</tt>
file. These are exactly the same as the files you get when you run
FLUID with the <tt>-c</tt> switch. 

The output file names are the same as the <tt>.fl</tt> file, with
the leading  directory and trailing ".fl" stripped, and
".h" or ".cxx" appended.  

<h4>File/Quit (Alt+q)</h4>
Exits FLUID.  You are asked for confirmation if you have changed the 
current data. 

<h4>Edit/Undo (Alt+z)</h4>
This isn't implemented yet.  You should do save  often so you can
recover from any mistakes you make. 

<h4>Edit/Cut (Alt+x)</h4>
Deletes the selected widgets and all of their children.  These are saved 
to a "clipboard" file and can be pasted back into any FLUID
window.

<h4>Edit/Copy (Alt+c)</h4>
Copies the selected widgets and all of their children to the "clipboard" 
file. 

<h4>Edit/Paste (Alt+c)</h4>
Pastes the widgets from the clipboard file. 

If the widget is a window, it is added to whatever function is 
selected, or contained in the current selection. 

If the widget is a normal widget, it is added to whatever window or 
group is selected.  If none is, it is added to the window or group that 
is the parent of the current selection. 

To avoid confusion, it is best to select exactly one widget before 
doing a paste. 

Cut/paste is the only way to change the parent of a widget. 

<h4>Edit/Select All (Alt+a)</h4>
Selects all widgets in the same group as the current selection. 

If they are all selected already then this selects all widgets in 
that group's parent.  Repeatedly typing Alt+a will select larger and 
larger groups of widgets until everything is selected. 

<h4>Edit/Open... (F1 or double click)</h4>
Displays the current widget in the attributes panel. If the widget is a window
and it is not visible then the window is shown instead.

<h4>Edit/Sort</h4>
Sorts the selected widgets into left to right, top to bottom 
order.  You need to do this to make navigation keys in FLTK work 
correctly.  You may then fine-tune the sorting with "Earlier" and 
"Later".  This does not affect the positions of windows or functions. 

<h4>Edit/Earlier (F2)</h4>
Moves all of the selected widgets one earlier in order among the 
children of their parent (if possible).  This will affect navigation 
order, and if the widgets overlap it will affect how they draw, as the 
later widget is drawn on top of the earlier one.  You can also use this 
to reorder functions, classes, and windows within functions. 

<h4>Edit/Later (F3)</h4>
Moves all of the selected widgets one later in order among the 
children of their parent (if possible). 

<h4>Edit/Group (F7)</h4>
Creates a new <tt>fltk::Group</tt> and make all the currently selected widgets
children of it.

<h4>Edit/Ungroup (F8)</h4>
Deletes the parent group if all the children of a group are selected.

<h4>Edit/Overlays on/off (Alt+Shift+O)</h4>
Toggles the display of the red overlays off, without changing the 
selection.  This makes it easier to see box borders and how the layout 
looks.  The overlays will be forced back on if you change the 
selection. 

<h4>Edit/Preferences (Alt+p)</h4>
Displays the preferences panel.  The alignment preferences control the
grid that all widgets snap to when you move and resize them, and for the
"snap" which is how far a widget has to be dragged from its original position 
to actually change.

The output filenames control the extensions or names of the files the are
generated by FLUID.  If you check the "Include .h from .cxx" button the code
file will include the header file automatically.

<h4>New/Code/Function</h4>
Creates a new C function.  You will be asked for a name for the 
function.  This name should be a legal C++ function template, without 
the return type.  You can pass arguments which can be referred to by 
code you type into the individual widgets. 

If the function contains any unnamed windows, it will be declared
as  returning a fltk::Window pointer.  The unnamed window will be returned
from it  (more than one unnamed window is useless).  If the function
contains  only named windows, it will be declared as returning nothing
(<tt>void</tt>). 

It is possible to make the <tt>.cxx</tt> output be a self-contained
program  that can be compiled and executed.  This is done by deleting
the  function name so <tt>main(argc,argv)</tt> is used.  The function 
will call <tt>show()</tt> on all the windows it creates and then call
<tt>fltk::run()</tt>.  This can also be used to test resize behavior or
other parts of the user  interface.

You can change the function name by double-clicking on the function. 

<h4>New/Window</h4>
Creates a new <tt>fltk::Window</tt> widget.  The window is added to the
currently selected  function, or to the function containing the
currently selected item.  The window will appear, sized to 100x100. 
You can resize it to whatever size you require. 

The widget panel will also appear and is described later in this
chapter.

<h4>New/...</h4>

All other items on the New menu are subclasses of
<tt>fltk::Widget</tt>.  Creating them will add them to the currently
selected group or window, or the group or window containing the
currently selected widget.  The initial dimensions and position are
chosen by copying the current widget, if possible.

When you create the widget you will get the widget's control panel, 
which is described later in this chapter. 

<h4>Help/About FLUID</h4>
Pops up a panel showing the version of FLUID. 

<h3>The Widget Panel</h3>

When you double-click on a widget or a set of widgets you will get 
the "widget attribute panel". 

When you change attributes using this panel, the changes are 
reflected immediately in the window. It is useful to hit the "no 
overlay" button (or type Alt+Shift+O) to hide the red overlay so you can see 
the widgets more accurately, especially when setting the box type.

If you have several widgets selected, they may have different values 
for the fields.  In this case the value for <I>one</I> of the widgets 
is shown.  But if you change this value, <I>all</I> of the selected 
widgets are changed to the new value.

Hitting "OK" makes the changes permanent.  Selecting a different 
widget also makes the changes permanent.  FLUID checks for simple 
syntax errors such as mismatched parenthesis in any code before 
saving any text.

"Revert" or "Cancel" put everything back to when you last brought up 
the panel or hit OK.  However in the current version of FLUID, changes 
to "visible" attributes (such as the color, label, box) are not undone 
by revert or cancel.  Changes to code like the callbacks are undone, 
however.

\image html fluid_widget.gif

<h3>Widget Attributes</h3>

<h4>Name (text field)</h4>

Name of a variable to declare, and to store a pointer to this 
widget into.  This variable will be of type "&lt;class&gt;*".  If the name is 
blank then no variable is created. 

You can name several widgets with "name[0]", "name[1]", "name[2]", 
etc.  This will cause FLUID to declare an array of pointers.  The array 
is big enough that the highest number found can be stored.  All widgets 
that in the array must be the same type. 

<h4>Type (upper-right pulldown menu)</h4>

Some classes have subtypes that modify their appearance or behavior. 
You pick the subtype off of this menu. 

<h4>Box (pulldown menu)</h4>
The boxtype to draw as a background for the widget. 

Many widgets will work, and draw faster, with a "frame" instead of a 
"box".  A frame does not draw the colored interior, leaving whatever 
was already there visible.  Be careful, as FLUID may draw this ok but 
the real program may leave unwanted stuff inside the widget. 

If a window is filled with child widgets, you can speed up redrawing 
by changing the window's box type to "NO_BOX".  FLUID will display a 
checkerboard for any areas that are not colored in by boxes. Note 
that this checkerboard is not drawn by the resulting program. Instead 
random garbage will be displayed.

<h4>Color</h4>

The color to draw the box with. 

<h4>Color2</h4>

Some widgets will use this color for certain parts.  FLUID does not 
always show the result of this: this is the color buttons draw in when 
pushed down, and the color of input fields when they have the focus. 

<h4>Label</h4>
String to print next to or inside the button. 

You can put newlines into the string to make multiple lines. The 
easiest way is by typing Ctrl+j. 

<h4>Label style (pull down menu)</h4>
How to draw the label.  Normal, shadowed, engraved, and embossed 
change the appearance of the text.  "symbol" requires the label to 
start with an '@' sign to draw a named symbol.

From this menu you can also pick Image.  This lets you use the
contents of a GIF, XPM, or XBM image file to label the widget.

<h4>Label Alignment (Buttons)</h4>
Where to draw the label.  The arrows put it on that side of the 
widget, you can combine the to put it in the corner.  The "box" button 
puts the label inside the widget, rather than outside. 

<h4>Label Font</h4>
Font to draw the label in.  Ignored by symbols, bitmaps, and pixmaps. 
Your program can change the actual font used by these "slots" in case 
you want some font other than the 16 provided. 

<h4>Label Size</h4>
Pixel size (height) for the font to draw the label in.  Ignored by symbols, 
bitmaps, and pixmaps.  To see the result without dismissing the panel, 
type the new number and then Tab. 

<h4>Label Color</h4>
Color to draw the label.  Ignored by pixmaps (bitmaps, however, do use 
this color as the foreground color). 

<h4>Text Font, Size, and Color</h4>
Some widgets display text, such as input fields, pull-down menus, and
browsers.

<h4>Visible</h4>
If you turn this off then the widget is hidden initially.  Don't change 
this for windows or for the immediate children of a Tabs group. 

<h4>Active</h4>
If you turn this off then the widget is deactivated initially.

<h4>Resizable</h4>
If a window is resizable or has an immediate child that is resizable, 
then the user will be able to resize it.  In addition all the size 
changes of a window or group will go "into" the resizable child.  If 
you have a large data display surrounded by buttons, you probably want 
that data area to be resizable. 

Only one child can be resizable.  Turning this on turns it off for 
the other children. 

You can get more complex behavior by making invisible boxes the 
resizable widget, or by using hierarchies of groups.  Unfortunately the 
only way to test it is to compile the program.  Resizing the FLUID 
window is <I>not</I> the same as what will happen in the user program. 

<h4>Hotspot</h4>
Each window may have exactly one hotspot (turning this on will turn 
off any others).  This will cause it to be positioned with that widget 
centered on the mouse.  This position is determined <I>when the FLUID 
function is called</I>, so you should call it immediately before showing 
the window.  If you want the window to hide and then reappear at a 
new position, you should have your program set the hotspot itself just 
before Window::show().

<h4>Subclass</h4>
This is how you use your own subclasses of fltk::Widget.  Whatever 
identifier you type in here will be the class that is instantiated. 

In addition, no <tt>#include</tt> header file is put in the
<tt>.h</tt> file.  You must provide a <tt>#include</tt> line as the
first line of the "Extra Code" which declares your subclass.

The class must be similar to the class you are spoofing.  It does not
have to be a subclass.  It is sometimes useful to change this to
another FLTK class, such as Window, to get FLUID's simulation closer
to the real one. You can also change the color or boxtype to simulate
your widget, even if the widget's implementation ignores these colors
or settings.

<h4>Extra Code</h4>

These four fields let you type in literal lines of code to dump into 
the <tt>.h</tt> or <tt>.cxx</tt> files. 

If the text starts with a <tt>#</tt> or the word <tt>extern</tt> then
FLUID thinks this is an "include" line, and it is written to the
<tt>.h</tt> file. If the same include line occurs several times then
only one copy is written.

All other lines are "code" lines.  The current widget is 
pointed to by the local variable <tt>o</tt>.  The window being constructed is 
pointed to by the local variable <tt>w</tt>.  You can also access any 
arguments passed to the function here, and any named widgets that are 
before this one. 

FLUID will check for matching parenthesis, braces, and quotes, but 
does not do much other error checking.  Be careful here, as it may be 
hard to figure out what widget is producing an error in the compiler. 
If you need more than four lines you probably should call a function in 
your own <tt>.cxx</tt> code. 

<h4>Callback</h4>

This can either be the name of a function, or a small snippet of code. 
If you enter anything but letters, numbers, and the underscore then FLUID
treats it as code. 

A name names a function in your own code.  It must be declared as 
<tt>void name(&lt;class&gt;*,void*)</tt>. 

A code snippet is inserted into a static function in the
<tt>.cxx</tt> output  file.  The function prototype is <tt>void
name(class *o, void *v)</tt> so that you can refer to the  widget as
<tt>o</tt> and the <tt>user_data()</tt> as <tt>v</tt>.  FLUID will
check for matching  parenthesis, braces, and quotes, but does not do
much other error  checking.  Be careful here, as it may be hard to
figure out what widget  is producing an error in the compiler. 

If the callback is blank then no callback is set. 

<h4>user_data</h4>

This is a value for the <tt>user_data()</tt> of the widget.  If blank the 
default value of zero is used.  This can be any piece of C code that 
can be cast to a <tt>void</tt> pointer.

<h4>User Data Type</h4>

The <tt>void *</tt> in the callback function prototypes is replaced with this. 
You may want to use <tt>long</tt> for old XForms code.  Be warned that 
anything other than <tt>void *</tt> is not guaranteed to work! 
However on most architectures other pointer types are ok, and <tt>long</tt> is 
usually ok, too. 

<h4>When</h4>

When to do the callback.  This can be "never", "changed", "release",
"enter key", or "no change".  The value of "enter key" is only useful
for text input fields.  The "no change" button means the callback is
done on the matching event even if the data is not changed.

There are other rare but useful values for the <tt>when()</tt> field that are 
not in the menu.  You should use the extra code fields to put these 
values in.

<h4>Border</h4>
On Window only. This button turns the window manager border on or
off.  On most window managers you will have to close the window and
reopen it to see the effect.

<h4>xclass</h4>
On Window only.  The string typed into here is passed to the X window
manager as the class.  This can change the icon or window decorations.
On most (all?)  window managers you will have to close the window and
reopen it to see the effect.

<h2>Selecting and Moving Widgets</h2>

Double-clicking a window name in the browser will display it, if not 
displayed yet.  From this display you can select widgets, sets of 
widgets, and move or resize them.  To close a window either 
double-click it or type Esc.

To select a widget, click it.  To select several widgets drag a 
rectangle around them.  Holding down shift will toggle the selection of 
the widgets instead. 

You cannot pick hidden widgets.  You also cannot choose some widgets 
if they are completely overlapped by later widgets.  Use the browser to 
select these widgets. 

The selected widgets are shown with a red "overlay" line around 
them.  You can move the widgets by dragging this box.  Or you can 
resize them by dragging the outer edges and corners.  Hold down the Alt 
key while dragging the mouse to defeat the snap-to-grid effect for fine 
positioning. 

If there is a tab box displayed you can change which child is 
visible by clicking on the file tabs.  The child you pick is selected. 

The arrow, tab, and shift+tab keys "navigate" the selection.  Left, 
right, tab, or shift+tab move to the next or previous widgets in the 
hierarchy.  Hit the right arrow enough and you will select every widget 
in the window.  Up/down widgets move to the previous/next widgets that 
overlap horizontally.  If the navigation does not seem to work you 
probably need to "Sort" the widgets.  This is important if you have 
input fields, as FLTK uses the same rules when using arrow keys to move 
between input fields. 

To "open" a widget, double click it.  To open several widgets select 
them and then type F1 or pick "Edit/Open" off the pop-up menu. 

Type Alt+o to temporarily toggle the overlay off without changing 
the selection, so you can see the widget borders. 

You can resize the window by using the window manager border 
controls.  FLTK will attempt to round the window size to the nearest 
multiple of the grid size and makes it big enough to contain all the 
widgets (it does this using illegal X methods, so it is possible it 
will barf with some window managers!).  Notice that the actual window 
in your program may not be resizable, and if it is, the effect on child 
widgets may be different. 

<h2>Image Labels</h2>

Selecting "Image..." off the label style pull-down menu will bring 
up a file chooser from which you pick the image file.  If an image has 
already been chosen, you can change the image used by picking 
"Image..." again.  The name of the image will appear in the "label" 
field, but you can't edit it. 

The <I>contents</I> of the image file are written to the <tt>.cxx</tt> file, 
so if you wish to distribute the C code, you only need to copy the <tt>.cxx</tt> 
file, not the images.  If many widgets share the same image then only 
one copy is written. 

However the <I>file name</I> is stored in the <tt>.fl</tt> file, so to
read the <tt>.fl</tt> file you need the image files as well.
Filenames are relative to the location the <tt>.fl</tt> file is (not
necessarily the current directory).  I recommend you either put the
images in the same directory as the <tt>.fl</tt> file, or use absolute
path names.

FLUID runs using the default visual of your X server.  This may be 8
bits, which will give you dithered images.  You may get better results
in your actual program by adding the code visual(fltk:\:RGB_COLOR) to
your code right before the first window is displayed.

All widgets with the same image on them share the same code and 
source X pixmap.  Thus once you have put an image on a widget, it is 
nearly free to put the same image on many other widgets. 

If you are using a painting program to edit an image: the only way 
to convince FLUID to read the image file again is to remove the image 
from all widgets that are using it (including ones in closed windows), 
which will cause it to free its internal copy, and then set the image 
again.  You may find it easier to exit FLUID and run it again. 

Don't rely on how FLTK crops images that are outside the widget, as 
this may change in future versions!  The cropping of inside labels will 
probably be unchanged. 

To more accurately place images, make a new "box" widget and put the 
image in that as the label.  This is also how you can put both an image 
and text label on the same widget.  If your widget is a button, and you 
want the image inside it, you must change the button's boxtype to 
fltk::UP_FRAME (or another frame), otherwise when it is pushed it will 
erase the image. 

FLUID can read X bitmap files, XPM files, GIF, and BMP images. If
compiled with the correct libraries (this is default on Linux) it
can read PNG and JPEG images.

I have not found any good editors for small iconic pictures.  For
pixmaps I have used <A
href="http://home.worldonline.dk/~torsten/xpaint/index.html">XPaint</A>.
This (and most other) painting programs are designed for large full
color images and are difficult to use to edit an image of small size
and few colors.

*/
