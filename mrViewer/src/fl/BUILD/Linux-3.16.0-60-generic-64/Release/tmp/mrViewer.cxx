// generated by Fast Light User Interface Designer (fluid) version 1.0303

#include "/media/Linux/code/applications/mrViewer/mrViewer/src/fl/BUILD/Linux-3.16.0-60-generic-64/Release/tmp/mrViewer.h"
#include "core/mrvI8N.h"
#include "core/mrvAudioEngine.h"
#include "core/exrImage.h"
#include "core/stubImage.h"
#include "core/mrvColorSpaces.h"
#include "core/mrvServer.h"
#include "core/mrvClient.h"
#include "gui/mrvMainWindow.h"
#include "gui/mrvImageView.h"
#include "gui/mrvImageBrowser.h"
#include "gui/mrvBrowser.h"
#include "gui/mrvPreferencesBrowser.h"
#include "mrvFileRequester.h"
#include "gui/mrvTimecode.h"
#include "gui/mrvTimeline.h"
#include "gui/mrvColorOps.h"
#include "gui/mrvHistogram.h"
#include "gui/mrvVectorscope.h"
#include "gui/mrvImageInformation.h"
#include "gui/mrvPreferences.h"
#include "gui/mrvLogDisplay.h"
#include "gui/mrvHotkey.h"
#include "mrvPlayback.h"
#include "mrvVersion.h"
#include "mrvIccProfileUI.h"
#include "mrvColorAreaUI.h"
#include "mrvEDLWindowUI.h"
#include "icons/icons.c"
#include "fltk/ColorChooser.h"
#include "fltk/ask.h"
#include "fltk/run.h"

mrv::CTLBrowser *browser=(mrv::CTLBrowser *)0;

static void cb_browser(mrv::CTLBrowser* o, std::string* v) {
  int elem = o->value();
if ( elem < 0 || elem >= o->children() ) { v->clear(); return; }
*v = o->child(elem)->label();
}

static void cb_Accept(Fl_Button*, fltk::Window* v) {
  v->make_exec_return(true);
}

static void cb_Cancel(Fl_Button*, fltk::Window* v) {
  v->make_exec_return(false);
}

std::string make_ctl_browser(std::string ctl, const char* prefix) {
  Fl_Double_Window* w;
  std::string orig = ctl;
  { Fl_Double_Window* o = new Fl_Double_Window(395, 440, "CTL Browser");
    w = o;
    o->hotspot(o);
    { Fl_Group* o = new Fl_Group(10, 25, 375, 405);
      { mrv::CTLBrowser* o = browser = new mrv::CTLBrowser(10, 25, 375, 365, "Select a CTL script");
        browser->box(FL_NO_BOX);
        browser->color(FL_BACKGROUND2_COLOR);
        browser->selection_color(FL_SELECTION_COLOR);
        browser->labeltype(FL_NORMAL_LABEL);
        browser->labelfont(0);
        browser->labelsize(14);
        browser->labelcolor(FL_FOREGROUND_COLOR);
        browser->callback((Fl_Callback*)cb_browser, (void*)(&ctl));
        browser->align(Fl_Align(FL_ALIGN_BOTTOM));
        browser->when(FL_WHEN_RELEASE_ALWAYS);
        o->set_prefix(prefix);
o->value(-1);
if ( !ctl.empty() )
{
  fltk::Widget* elem = o->find( ctl.c_str() );

  for (int i = 0; i < o->children(); ++i )
  {
    if ( o->child(i) == elem ) {
      o->value(i); break;
    }
  }
}
      } // mrv::CTLBrowser* browser
      { Fl_Button* o = new Fl_Button(205, 400, 85, 25, "Accept");
        o->callback((Fl_Callback*)cb_Accept, (void*)(w));
      } // Fl_Button* o
      { Fl_Button* o = new Fl_Button(300, 400, 80, 25, "Cancel");
        o->callback((Fl_Callback*)cb_Cancel, (void*)(w));
      } // Fl_Button* o
      o->end();
    } // Fl_Group* o
    o->set_modal();
    o->end();
    o->resizable(o);
  } // Fl_Double_Window* o
  if (!w->exec())
  	return orig;
  return ctl;
}

void ReelUI::cb__i(Fl_Choice* o, mrv::ImageBrowser* v) {
  v->reel(o->value());
}
void ReelUI::cb_(Fl_Choice* o, mrv::ImageBrowser* v) {
  ((ReelUI*)(o->parent()->parent()->user_data()))->cb__i(o,v);
}

void ReelUI::cb_1_i(Fl_Button*, mrv::ImageBrowser* v) {
  const char* name = fltk::input("Reel Name", "reel" );
if ( name == NULL ) return;
v->new_reel(name);
}
void ReelUI::cb_1(Fl_Button* o, mrv::ImageBrowser* v) {
  ((ReelUI*)(o->parent()->parent()->parent()->user_data()))->cb_1_i(o,v);
}

void ReelUI::cb_2_i(Fl_Button*, mrv::ImageBrowser* v) {
  v->save_reel();
}
void ReelUI::cb_2(Fl_Button* o, mrv::ImageBrowser* v) {
  ((ReelUI*)(o->parent()->parent()->parent()->user_data()))->cb_2_i(o,v);
}

void ReelUI::cb_3_i(Fl_Button*, mrv::ImageBrowser* v) {
  v->remove_reel();
}
void ReelUI::cb_3(Fl_Button* o, mrv::ImageBrowser* v) {
  ((ReelUI*)(o->parent()->parent()->parent()->user_data()))->cb_3_i(o,v);
}

void ReelUI::cb_4_i(Fl_Button*, mrv::ImageBrowser* v) {
  v->open();
}
void ReelUI::cb_4(Fl_Button* o, mrv::ImageBrowser* v) {
  ((ReelUI*)(o->parent()->parent()->parent()->user_data()))->cb_4_i(o,v);
}

void ReelUI::cb_5_i(Fl_Button*, mrv::ImageBrowser* v) {
  v->save();
}
void ReelUI::cb_5(Fl_Button* o, mrv::ImageBrowser* v) {
  ((ReelUI*)(o->parent()->parent()->parent()->user_data()))->cb_5_i(o,v);
}

void ReelUI::cb_6_i(Fl_Button*, mrv::ImageBrowser* v) {
  v->clone_current();
}
void ReelUI::cb_6(Fl_Button* o, mrv::ImageBrowser* v) {
  ((ReelUI*)(o->parent()->parent()->parent()->user_data()))->cb_6_i(o,v);
}

void ReelUI::cb_7_i(Fl_Button*, mrv::ImageBrowser* v) {
  v->remove_current();
}
void ReelUI::cb_7(Fl_Button* o, mrv::ImageBrowser* v) {
  ((ReelUI*)(o->parent()->parent()->parent()->user_data()))->cb_7_i(o,v);
}

void ReelUI::cb_CTL_i(Fl_Button*, mrv::ImageBrowser* v) {
  v->attach_ctl_script();
}
void ReelUI::cb_CTL(Fl_Button* o, mrv::ImageBrowser* v) {
  ((ReelUI*)(o->parent()->parent()->parent()->user_data()))->cb_CTL_i(o,v);
}

void ReelUI::cb_uiBGButton_i(Fl_Button*, mrv::ImageBrowser* v) {
  v->change_background();
}
void ReelUI::cb_uiBGButton(Fl_Button* o, mrv::ImageBrowser* v) {
  ((ReelUI*)(o->parent()->parent()->parent()->user_data()))->cb_uiBGButton_i(o,v);
}

void ReelUI::cb_uiEDLButton_i(Fl_Button*, mrv::ImageBrowser* v) {
  v->toggle_edl();
}
void ReelUI::cb_uiEDLButton(Fl_Button* o, mrv::ImageBrowser* v) {
  ((ReelUI*)(o->parent()->parent()->parent()->user_data()))->cb_uiEDLButton_i(o,v);
}

Fl_Double_Window* ReelUI::make_window(ViewerUI* main) {
  { Fl_Double_Window* o = uiMain = new Fl_Double_Window(405, 350, "Reel List");
    uiMain->user_data((void*)(this));
    { mrv::ImageBrowser* o = uiBrowser = new mrv::ImageBrowser(0, 32, 405, 318);
      uiBrowser->box(FL_UP_BOX);
      uiBrowser->color(FL_BACKGROUND2_COLOR);
      uiBrowser->selection_color(FL_SELECTION_COLOR);
      uiBrowser->labeltype(FL_NORMAL_LABEL);
      uiBrowser->labelfont(0);
      uiBrowser->labelsize(14);
      uiBrowser->labelcolor(FL_FOREGROUND_COLOR);
      uiBrowser->align(Fl_Align(FL_ALIGN_BOTTOM));
      uiBrowser->when(FL_WHEN_RELEASE_ALWAYS);
      o->main( main );
o->scrollbar.buttoncolor( mrv::lighter( o->color(), 0x20 ) );
o->hscrollbar.buttoncolor( mrv::lighter( o->color(), 0x20 ));
o->scrollbar.color( o->buttoncolor() );
o->hscrollbar.color( o->buttoncolor() );
    } // mrv::ImageBrowser* uiBrowser
    { Fl_Group* o = new Fl_Group(0, 0, 405, 32);
      o->box(FL_UP_BOX);
      { Fl_Choice* o = new Fl_Choice(5, 5, 120, 20);
        o->box(FL_THIN_DOWN_BOX);
        o->down_box(FL_BORDER_BOX);
        o->callback((Fl_Callback*)cb_, (void*)(uiBrowser));
        o->align(Fl_Align(36));
        uiBrowser->reel_choice(o);
      } // Fl_Choice* o
      { uiReelOps = new Fl_Group(130, 3, 81, 26);
        { Fl_Button* o = new Fl_Button(130, 3, 26, 26);
          o->tooltip("Create a new reel");
          o->shortcut(0x4006e);
          o->callback((Fl_Callback*)cb_1, (void*)(uiBrowser));
          o->image( reel_new_24 );
        } // Fl_Button* o
        { Fl_Button* o = new Fl_Button(156, 3, 26, 26);
          o->tooltip("Save current reel");
          o->callback((Fl_Callback*)cb_2, (void*)(uiBrowser));
          o->image( reel_save_24 );
        } // Fl_Button* o
        { Fl_Button* o = new Fl_Button(182, 3, 26, 26);
          o->tooltip("Delete current reel");
          o->callback((Fl_Callback*)cb_3, (void*)(uiBrowser));
          o->image( reel_delete_24 );
        } // Fl_Button* o
        uiReelOps->end();
      } // Fl_Group* uiReelOps
      { uiImageOps = new Fl_Group(216, 3, 105, 26);
        { Fl_Button* o = new Fl_Button(217, 3, 26, 26);
          o->tooltip("Open new image, sequence or movie");
          o->shortcut(0x4006f);
          o->callback((Fl_Callback*)cb_4, (void*)(uiBrowser));
          o->image(file_open_24);
        } // Fl_Button* o
        { Fl_Button* o = new Fl_Button(243, 3, 26, 26);
          o->tooltip("Save current image, sequence or movie.");
          o->shortcut(0x40073);
          o->callback((Fl_Callback*)cb_5, (void*)(uiBrowser));
          o->image(file_save_24);
        } // Fl_Button* o
        { Fl_Button* o = new Fl_Button(269, 3, 26, 26);
          o->tooltip("Clone image");
          o->shortcut(0x40063);
          o->callback((Fl_Callback*)cb_6, (void*)(uiBrowser));
          o->image(file_clone_24);
        } // Fl_Button* o
        { Fl_Button* o = new Fl_Button(295, 3, 26, 26);
          o->tooltip("Remove current image from reel.");
          o->shortcut(0xffff);
          o->callback((Fl_Callback*)cb_7, (void*)(uiBrowser));
          o->image(file_delete_24);
        } // Fl_Button* o
        uiImageOps->end();
      } // Fl_Group* uiImageOps
      { uiViewerOps = new Fl_Group(324, 3, 79, 26);
        { Fl_Button* o = new Fl_Button(324, 3, 26, 26, "CTL");
          o->tooltip("Set image CTL script");
          o->labelfont(1);
          o->callback((Fl_Callback*)cb_CTL, (void*)(uiBrowser));
        } // Fl_Button* o
        { uiBGButton = new Fl_Button(350, 3, 26, 26, "BG");
          uiBGButton->tooltip("Set reel images as background (needs EDL).");
          uiBGButton->labelfont(1);
          uiBGButton->callback((Fl_Callback*)cb_uiBGButton, (void*)(uiBrowser));
        } // Fl_Button* uiBGButton
        { uiEDLButton = new Fl_Button(376, 3, 26, 26, "EDL");
          uiEDLButton->tooltip("Toggle Reel in Timeline");
          uiEDLButton->labelfont(1);
          uiEDLButton->labelsize(11);
          uiEDLButton->callback((Fl_Callback*)cb_uiEDLButton, (void*)(uiBrowser));
        } // Fl_Button* uiEDLButton
        uiViewerOps->end();
      } // Fl_Group* uiViewerOps
      o->end();
    } // Fl_Group* o
    o->size_range(350,320);
// Make the window transient
o->child_of( main->uiMain );
    uiMain->end();
    uiMain->resizable(uiMain);
  } // Fl_Double_Window* uiMain
  return uiMain;
}

ReelUI::ReelUI(ViewerUI* m) {
  make_window( m );
}

ReelUI::~ReelUI() {
  delete uiBrowser; uiBrowser = NULL;
  delete uiMain; uiMain = NULL;
}

Fl_Double_Window* ImageInfoUI::make_window(ViewerUI* main) {
  { Fl_Double_Window* o = uiMain = new Fl_Double_Window(505, 530, "Media Information");
    uiMain->user_data((void*)(this));
    { mrv::ImageInformation* o = uiInfoText = new mrv::ImageInformation(2, 2, 498, 526);
      uiInfoText->box(FL_NO_BOX);
      uiInfoText->color(FL_BACKGROUND_COLOR);
      uiInfoText->selection_color(FL_BACKGROUND_COLOR);
      uiInfoText->labeltype(FL_NORMAL_LABEL);
      uiInfoText->labelfont(0);
      uiInfoText->labelsize(14);
      uiInfoText->labelcolor(FL_FOREGROUND_COLOR);
      uiInfoText->align(Fl_Align(FL_ALIGN_TOP));
      uiInfoText->when(FL_WHEN_RELEASE);
      o->main( main );
      uiInfoText->end();
    } // mrv::ImageInformation* uiInfoText
    // Make the window transient
o->child_of( main->uiMain );
    uiMain->end();
    uiMain->resizable(uiMain);
  } // Fl_Double_Window* uiMain
  return uiMain;
}

ImageInfoUI::ImageInfoUI(ViewerUI* m) {
  make_window( m );
}

ImageInfoUI::~ImageInfoUI() {
  delete uiMain; uiMain = NULL;
}

void AboutUI::cb_8_i(Fl_Tabs*, mrv::ViewerUI* v) {
  v->uiAbout->uiGPUInfo->clear();
v->uiAbout->uiGPUInfo->add( mrv::gpu_information( v ).c_str() );
}
void AboutUI::cb_8(Fl_Tabs* o, mrv::ViewerUI* v) {
  ((AboutUI*)(o->parent()->user_data()))->cb_8_i(o,v);
}

Fl_Double_Window* AboutUI::make_window(ViewerUI* main) {
  { Fl_Double_Window* o = uiMain = new Fl_Double_Window(445, 395, "About mrViewer");
    uiMain->user_data((void*)(this));
    { Fl_Tabs* o = new Fl_Tabs(4, 4, 441, 391);
      o->callback((Fl_Callback*)cb_8, (void*)(main));
      { Fl_Group* o = new Fl_Group(4, 24, 440, 371, "mrViewer");
        { Fl_Text_Display* o = new Fl_Text_Display(19, 39, 415, 345);
          o->text( mrv::about_message().c_str() );
        } // Fl_Text_Display* o
        o->end();
      } // Fl_Group* o
      { Fl_Group* o = new Fl_Group(4, 24, 440, 371, "HW");
        o->hide();
        { Fl_Text_Display* o = uiCPUInfo = new Fl_Text_Display(19, 54, 415, 96, "CPU Information");
          o->text( mrv::cpu_information().c_str() );
        } // Fl_Text_Display* uiCPUInfo
        { mrv::Browser* o = uiGPUInfo = new mrv::Browser(20, 175, 415, 205, "GPU Information");
          uiGPUInfo->box(FL_NO_BOX);
          uiGPUInfo->color(FL_BACKGROUND2_COLOR);
          uiGPUInfo->selection_color(FL_SELECTION_COLOR);
          uiGPUInfo->labeltype(FL_NORMAL_LABEL);
          uiGPUInfo->labelfont(0);
          uiGPUInfo->labelsize(14);
          uiGPUInfo->labelcolor(FL_FOREGROUND_COLOR);
          uiGPUInfo->align(Fl_Align(FL_ALIGN_BOTTOM));
          uiGPUInfo->when(FL_WHEN_RELEASE_ALWAYS);
          static int widths[] = {
160,
o->w()-160,
0
};
o->column_widths( widths );
o->value(-1);
        } // mrv::Browser* uiGPUInfo
        o->end();
      } // Fl_Group* o
      { Fl_Group* o = new Fl_Group(4, 24, 445, 370, "Formats");
        o->hide();
        { Fl_Browser* o = new Fl_Browser(19, 39, 415, 345);
          static const char* col_labels[] = {
"",
"",
"",
"Extension",
"Handler",
"Format Name",
0
};

static int col_widths[] = {
20,
20,
20,
120,
120,
300,
0
};
o->column_labels( col_labels );
o->column_widths( col_widths );


ffmpeg_formats(*o);
o->value(-1);
        } // Fl_Browser* o
        o->end();
      } // Fl_Group* o
      { Fl_Group* o = new Fl_Group(4, 24, 445, 375, "Codecs");
        o->hide();
        { Fl_Browser* o = new Fl_Browser(19, 44, 410, 150, "Video");
          ffmpeg_video_codecs(*o);
o->value(-1);
        } // Fl_Browser* o
        { Fl_Browser* o = new Fl_Browser(19, 214, 415, 110, "Audio");
          ffmpeg_audio_codecs(*o);
o->value(-1);
        } // Fl_Browser* o
        { Fl_Browser* o = new Fl_Browser(19, 339, 415, 55, "Subtitles");
          ffmpeg_subtitle_codecs(*o);
o->value(-1);
        } // Fl_Browser* o
        o->end();
      } // Fl_Group* o
      { Fl_Group* o = new Fl_Group(4, 24, 445, 370, "Protocols");
        o->hide();
        o->deactivate();
        { Fl_Browser* o = new Fl_Browser(19, 39, 415, 345);
          o->add( ffmpeg_protocols().c_str() );
o->value(-1);
        } // Fl_Browser* o
        o->end();
      } // Fl_Group* o
      { Fl_Group* o = new Fl_Group(4, 24, 445, 370, "Motion Estimation Methods");
        o->hide();
        { Fl_Browser* o = new Fl_Browser(19, 39, 415, 345);
          static int col_widths[] = {
120,
300,
0
};
o->column_widths( col_widths );
o->add( ffmpeg_motion_estimation_methods().c_str() );
o->value(-1);
        } // Fl_Browser* o
        o->end();
      } // Fl_Group* o
      o->end();
    } // Fl_Tabs* o
    // Make the window transient
o->child_of( main->uiMain );
    uiMain->set_modal();
    uiMain->end();
    uiMain->resizable(uiMain);
  } // Fl_Double_Window* uiMain
  return uiMain;
}

AboutUI::AboutUI(ViewerUI* m) {
  make_window( m );
}

AboutUI::~AboutUI() {
  delete uiMain; uiMain = NULL;
}

void GL3dViewUI::cb_uiMain_i(mrv::GlWindow3d* o, GL3dViewUI* v) {
  v->main()->uiView->send( "GL3dView 0" );
o->hide();
}
void GL3dViewUI::cb_uiMain(mrv::GlWindow3d* o, GL3dViewUI* v) {
  ((GL3dViewUI*)(o->user_data()))->cb_uiMain_i(o,v);
}

mrv::GlWindow3d* GL3dViewUI::make_window(ViewerUI* main) {
  { mrv::GlWindow3d* o = uiMain = new mrv::GlWindow3d(325, 240, "3d View");
    uiMain->box(FL_FLAT_BOX);
    uiMain->color(FL_BACKGROUND_COLOR);
    uiMain->selection_color(FL_BACKGROUND_COLOR);
    uiMain->labeltype(FL_NO_LABEL);
    uiMain->labelfont(0);
    uiMain->labelsize(14);
    uiMain->labelcolor(FL_FOREGROUND_COLOR);
    uiMain->callback((Fl_Callback*)cb_uiMain, (void*)(this));
    uiMain->align(Fl_Align(FL_ALIGN_TOP));
    uiMain->when(FL_WHEN_RELEASE);
    // Make the window transient
main_ = main;
o->child_of( main->uiMain );
    uiMain->end();
    uiMain->resizable(uiMain);
  } // mrv::GlWindow3d* uiMain
  return uiMain;
}

GL3dViewUI::GL3dViewUI(ViewerUI* m) {
  make_window( m );
}

GL3dViewUI::~GL3dViewUI() {
  delete uiMain; uiMain = NULL;
}

mrv::ViewerUI* GL3dViewUI::main() {
  return main_;
}

void VectorscopeUI::cb_uiMain1_i(Fl_Double_Window* o, VectorscopeUI* v) {
  v->main()->uiView->send( "VectorscopeWindow 0" );
o->hide();
}
void VectorscopeUI::cb_uiMain1(Fl_Double_Window* o, VectorscopeUI* v) {
  ((VectorscopeUI*)(o->user_data()))->cb_uiMain1_i(o,v);
}

Fl_Double_Window* VectorscopeUI::make_window(ViewerUI* main) {
  { Fl_Double_Window* o = uiMain = new Fl_Double_Window(325, 240, "Vectorscope");
    uiMain->callback((Fl_Callback*)cb_uiMain1, (void*)(this));
    { mrv::Vectorscope* o = uiVectorscope = new mrv::Vectorscope(4, 4, 319, 231);
      uiVectorscope->box(FL_NO_BOX);
      uiVectorscope->color(FL_BACKGROUND_COLOR);
      uiVectorscope->selection_color(FL_BACKGROUND_COLOR);
      uiVectorscope->labeltype(FL_NORMAL_LABEL);
      uiVectorscope->labelfont(0);
      uiVectorscope->labelsize(14);
      uiVectorscope->labelcolor(FL_FOREGROUND_COLOR);
      uiVectorscope->align(Fl_Align(FL_ALIGN_CENTER));
      uiVectorscope->when(FL_WHEN_RELEASE);
      o->main( main );
    } // mrv::Vectorscope* uiVectorscope
    // Make the window transient
main_ = main;
o->child_of( main->uiMain );
    uiMain->end();
    uiMain->resizable(uiMain);
  } // Fl_Double_Window* uiMain
  return uiMain;
}

VectorscopeUI::VectorscopeUI(ViewerUI* m) {
  make_window( m );
}

VectorscopeUI::~VectorscopeUI() {
  delete uiMain; uiMain = NULL;
}

mrv::ViewerUI* VectorscopeUI::main() {
  return main_;
}

void HistogramUI::cb_uiMain2_i(Fl_Double_Window* o, HistogramUI* v) {
  v->main()->uiView->send( "HistogramWindow 0" );
o->hide();
}
void HistogramUI::cb_uiMain2(Fl_Double_Window* o, HistogramUI* v) {
  ((HistogramUI*)(o->user_data()))->cb_uiMain2_i(o,v);
}

Fl_Double_Window* HistogramUI::make_window(mrv::ViewerUI* main) {
  { Fl_Double_Window* o = uiMain = new Fl_Double_Window(325, 240, "Histogram");
    uiMain->callback((Fl_Callback*)cb_uiMain2, (void*)(this));
    { Fl_Pack* o = new Fl_Pack(3, 5, 321, 230);
      { mrv::Histogram* o = uiHistogram = new mrv::Histogram(4, 5, 319, 190);
        uiHistogram->box(FL_NO_BOX);
        uiHistogram->color(FL_BACKGROUND_COLOR);
        uiHistogram->selection_color(FL_BACKGROUND_COLOR);
        uiHistogram->labeltype(FL_NORMAL_LABEL);
        uiHistogram->labelfont(0);
        uiHistogram->labelsize(14);
        uiHistogram->labelcolor(FL_FOREGROUND_COLOR);
        uiHistogram->align(Fl_Align(FL_ALIGN_CENTER));
        uiHistogram->when(FL_WHEN_RELEASE);
        Fl_Group::current()->resizable(uiHistogram);
        o->main( main );
      } // mrv::Histogram* uiHistogram
      { Fl_Group* o = new Fl_Group(10, 200, 310, 30);
        { Fl_Group* o = new Fl_Group(10, 205, 160, 25);
          o->end();
        } // Fl_Group* o
        { Fl_Group* o = new Fl_Group(174, 205, 146, 25);
          o->end();
        } // Fl_Group* o
        o->end();
      } // Fl_Group* o
      o->end();
    } // Fl_Pack* o
    // Make the window transient
main_ = main;
o->child_of( main->uiMain );
o->size_range(325, 80);
    uiMain->end();
    uiMain->resizable(uiMain);
  } // Fl_Double_Window* uiMain
  return uiMain;
}

HistogramUI::HistogramUI(ViewerUI* m) {
  make_window( m );
}

HistogramUI::~HistogramUI() {
  delete uiMain; uiMain = NULL;
}

mrv::ViewerUI* HistogramUI::main() {
  return main_;
}

Fl_Menu_Item PreferencesUI::menu_uiPrefsTimelineDisplay[] = {
 {"Frames", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Seconds", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Time", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Non-Drop Frame Timecode", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Drop Frame Timecode", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0}
};

Fl_Menu_Item PreferencesUI::menu_uiPrefsCropArea[] = {
 {"0.00 None", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"1.00 Square", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"1.19 Movietone", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"1.37 Academy (Full Frame)", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"1.50 Still Photo", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"1.56 STV - HDTV (14:9)", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"1.66 European Widescreen", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"1.77 HDTV (16:9)", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"1.85 Widescreen (3-perf)", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"2.10 VistaVision", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"2.20 70mm", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"2.35 CinemaScope (old 2.35)", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"2.39 Panavision (new 2.35)", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"4.00 Polyvision", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0}
};

void PreferencesUI::cb_uiPrefsUIBG_i(Fl_Button* o, void*) {
  uchar r, g, b;
fltk::split_color(o->color(),r,g,b);
if (!fltk::color_chooser("Pick View Background Color", r,g,b)) return;
o->color( fltk::color( r,g,b ) );
o->redraw();
}
void PreferencesUI::cb_uiPrefsUIBG(Fl_Button* o, void* v) {
  ((PreferencesUI*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_uiPrefsUIBG_i(o,v);
}

void PreferencesUI::cb_uiPrefsUIText_i(Fl_Button* o, mrv::PreferencesUI* v) {
  uchar r, g, b;
fltk::split_color(o->color(),r,g,b);
if (!fltk::color_chooser("Pick View Text Overlay Color", r,g,b)) return;
o->color( fltk::color( r,g,b ) );
o->redraw();
v->refresh();
}
void PreferencesUI::cb_uiPrefsUIText(Fl_Button* o, mrv::PreferencesUI* v) {
  ((PreferencesUI*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_uiPrefsUIText_i(o,v);
}

void PreferencesUI::cb_uiPrefsUISelection_i(Fl_Button* o, mrv::PreferencesUI* v) {
  uchar r, g, b;
fltk::split_color(o->color(),r,g,b);
if (!fltk::color_chooser("Pick View Selection Color", r,g,b)) return;
o->color( fltk::color( r,g,b ) );
o->redraw();
v->refresh();
}
void PreferencesUI::cb_uiPrefsUISelection(Fl_Button* o, mrv::PreferencesUI* v) {
  ((PreferencesUI*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_uiPrefsUISelection_i(o,v);
}

void PreferencesUI::cb_uiPrefsUISelectionText_i(Fl_Button* o, mrv::PreferencesUI* v) {
  uchar r, g, b;
fltk::split_color(o->color(),r,g,b);
if (!fltk::color_chooser("Pick View Text Overlay Color", r,g,b)) return;
o->color( fltk::color( r,g,b ) );
o->redraw();
v->refresh();
}
void PreferencesUI::cb_uiPrefsUISelectionText(Fl_Button* o, mrv::PreferencesUI* v) {
  ((PreferencesUI*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_uiPrefsUISelectionText_i(o,v);
}

void PreferencesUI::cb_uiPrefsViewBG_i(Fl_Button* o, void*) {
  uchar r, g, b;
fltk::split_color(o->color(),r,g,b);
if (!fltk::color_chooser("Pick View Background Color", r,g,b)) return;
o->color( fltk::color( r,g,b ) );
o->redraw();
}
void PreferencesUI::cb_uiPrefsViewBG(Fl_Button* o, void* v) {
  ((PreferencesUI*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_uiPrefsViewBG_i(o,v);
}

void PreferencesUI::cb_uiPrefsViewTextOverlay_i(Fl_Button* o, mrv::PreferencesUI* v) {
  uchar r, g, b;
fltk::split_color(o->color(),r,g,b);
if (!fltk::color_chooser("Pick View Text Overlay Color", r,g,b)) return;
o->color( fltk::color( r,g,b ) );
o->redraw();
v->refresh();
}
void PreferencesUI::cb_uiPrefsViewTextOverlay(Fl_Button* o, mrv::PreferencesUI* v) {
  ((PreferencesUI*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_uiPrefsViewTextOverlay_i(o,v);
}

void PreferencesUI::cb_uiPrefsViewSelection_i(Fl_Button* o, mrv::PreferencesUI* v) {
  uchar r, g, b;
fltk::split_color(o->color(),r,g,b);
if (!fltk::color_chooser("Pick View Selection Color", r,g,b)) return;
o->color( fltk::color( r,g,b ) );
o->redraw();
v->refresh();
}
void PreferencesUI::cb_uiPrefsViewSelection(Fl_Button* o, mrv::PreferencesUI* v) {
  ((PreferencesUI*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_uiPrefsViewSelection_i(o,v);
}

void PreferencesUI::cb_uiPrefsViewHud_i(Fl_Button* o, mrv::PreferencesUI* v) {
  uchar r, g, b;
fltk::split_color(o->color(),r,g,b);
if (!fltk::color_chooser("Pick HUD Color", r,g,b)) return;
o->color( fltk::color( r,g,b ) );
o->redraw();
v->refresh();
}
void PreferencesUI::cb_uiPrefsViewHud(Fl_Button* o, mrv::PreferencesUI* v) {
  ((PreferencesUI*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_uiPrefsViewHud_i(o,v);
}

Fl_Menu_Item PreferencesUI::menu_uiPrefsLoopMode[] = {
 {"Stop", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Loop", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Ping Pong", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0}
};

Fl_Menu_Item PreferencesUI::menu_uiPrefsCacheScale[] = {
 {"1:1", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"1:2", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"1:4", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"1:8", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0}
};

void PreferencesUI::cb_uiPrefsCacheFPS_i(Fl_Light_Button*, fltk::ValueSlider* v) {
  v->activate( !v->active() );
}
void PreferencesUI::cb_uiPrefsCacheFPS(Fl_Light_Button* o, fltk::ValueSlider* v) {
  ((PreferencesUI*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_uiPrefsCacheFPS_i(o,v);
}

void PreferencesUI::cb_ODT_algorithm_i(Fl_Choice* o, mrv::PreferencesUI* v) {
  Preferences::LutAlgorithm x = (Preferences::LutAlgorithm) o->value();
uiODT_CTL->activate();
uiODT_ICC->activate();
if ( x == Preferences::kLutOnlyCTL )
    uiODT_ICC->deactivate();
if ( x == Preferences::kLutOnlyICC )
    uiODT_CTL->deactivate();
v->refresh();
}
void PreferencesUI::cb_ODT_algorithm(Fl_Choice* o, mrv::PreferencesUI* v) {
  ((PreferencesUI*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_ODT_algorithm_i(o,v);
}

Fl_Menu_Item PreferencesUI::menu_ODT_algorithm[] = {
 {"Prefer CTL", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Always CTL", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Prefer ICC", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Always ICC", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0}
};

void PreferencesUI::cb_RT_algorithm_i(Fl_Choice* o, mrv::PreferencesUI* v) {
  Preferences::LutAlgorithm x = (Preferences::LutAlgorithm) o->value();
uiRT_CTL->activate();
uiRT_ICC->activate();
if ( x == Preferences::kLutOnlyCTL )
    uiRT_ICC->deactivate();
if ( x == Preferences::kLutOnlyICC )
    uiRT_CTL->deactivate();
v->refresh();
}
void PreferencesUI::cb_RT_algorithm(Fl_Choice* o, mrv::PreferencesUI* v) {
  ((PreferencesUI*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_RT_algorithm_i(o,v);
}

Fl_Menu_Item PreferencesUI::menu_RT_algorithm[] = {
 {"Prefer CTL", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Always CTL", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Prefer ICC", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Always ICC", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0}
};

void PreferencesUI::cb_uiLUT_quality_i(Fl_Choice*, mrv::PreferencesUI* v) {
  v->refresh();
}
void PreferencesUI::cb_uiLUT_quality(Fl_Choice* o, mrv::PreferencesUI* v) {
  ((PreferencesUI*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_uiLUT_quality_i(o,v);
}

Fl_Menu_Item PreferencesUI::menu_uiLUT_quality[] = {
 {"No Baking", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"32x32x32", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"64x64x64", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"96x96x96", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"128x128x128", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0}
};

void PreferencesUI::cb_uiICC_intent_i(Fl_Choice*, mrv::PreferencesUI* v) {
  v->refresh();
}
void PreferencesUI::cb_uiICC_intent(Fl_Choice* o, mrv::PreferencesUI* v) {
  ((PreferencesUI*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_uiICC_intent_i(o,v);
}

Fl_Menu_Item PreferencesUI::menu_uiICC_intent[] = {
 {"Perceptual", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Relative Colorimetric", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Absolute Colorimetric", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Saturation", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0}
};

void PreferencesUI::cb_uiODT_CTL_transform_i(Fl_Input* o, mrv::PreferencesUI* v) {
  mrv::Preferences::ODT_CTL_transform = o->text();
v->refresh();
}
void PreferencesUI::cb_uiODT_CTL_transform(Fl_Input* o, mrv::PreferencesUI* v) {
  ((PreferencesUI*)(o->parent()->parent()->parent()->parent()->parent()->parent()->user_data()))->cb_uiODT_CTL_transform_i(o,v);
}

void PreferencesUI::cb_Pick_i(Fl_Button*, void*) {
  std::string c = make_ctl_browser(uiODT_CTL_transform->text(), "ODT");
if (c.empty()) return;
uiODT_CTL_transform->text(c.c_str());
uiODT_CTL_transform->do_callback();
}
void PreferencesUI::cb_Pick(Fl_Button* o, void* v) {
  ((PreferencesUI*)(o->parent()->parent()->parent()->parent()->parent()->parent()->user_data()))->cb_Pick_i(o,v);
}

void PreferencesUI::cb_uiODT_CTL_chromaticities_red_x_i(Fl_Value_Input* o, void*) {
  mrv::Preferences::ODT_CTL_chromaticities.red.x = (float) o->value();
}
void PreferencesUI::cb_uiODT_CTL_chromaticities_red_x(Fl_Value_Input* o, void* v) {
  ((PreferencesUI*)(o->parent()->parent()->parent()->parent()->parent()->parent()->parent()->user_data()))->cb_uiODT_CTL_chromaticities_red_x_i(o,v);
}

void PreferencesUI::cb_uiODT_CTL_chromaticities_red_y_i(Fl_Value_Input* o, void*) {
  mrv::Preferences::ODT_CTL_chromaticities.red.y = (float) o->value();
}
void PreferencesUI::cb_uiODT_CTL_chromaticities_red_y(Fl_Value_Input* o, void* v) {
  ((PreferencesUI*)(o->parent()->parent()->parent()->parent()->parent()->parent()->parent()->user_data()))->cb_uiODT_CTL_chromaticities_red_y_i(o,v);
}

void PreferencesUI::cb_uiODT_CTL_chromaticities_green_x_i(Fl_Value_Input* o, void*) {
  mrv::Preferences::ODT_CTL_chromaticities.green.x = (float) o->value();
}
void PreferencesUI::cb_uiODT_CTL_chromaticities_green_x(Fl_Value_Input* o, void* v) {
  ((PreferencesUI*)(o->parent()->parent()->parent()->parent()->parent()->parent()->parent()->user_data()))->cb_uiODT_CTL_chromaticities_green_x_i(o,v);
}

void PreferencesUI::cb_uiODT_CTL_chromaticities_green_y_i(Fl_Value_Input* o, void*) {
  mrv::Preferences::ODT_CTL_chromaticities.green.x = (float) o->value();
}
void PreferencesUI::cb_uiODT_CTL_chromaticities_green_y(Fl_Value_Input* o, void* v) {
  ((PreferencesUI*)(o->parent()->parent()->parent()->parent()->parent()->parent()->parent()->user_data()))->cb_uiODT_CTL_chromaticities_green_y_i(o,v);
}

void PreferencesUI::cb_uiODT_CTL_chromaticities_blue_x_i(Fl_Value_Input* o, mrv::PreferencesUI* v) {
  mrv::Preferences::ODT_CTL_chromaticities.green.x = (float) o->value(); 
v->refresh();
}
void PreferencesUI::cb_uiODT_CTL_chromaticities_blue_x(Fl_Value_Input* o, mrv::PreferencesUI* v) {
  ((PreferencesUI*)(o->parent()->parent()->parent()->parent()->parent()->parent()->parent()->user_data()))->cb_uiODT_CTL_chromaticities_blue_x_i(o,v);
}

void PreferencesUI::cb_uiODT_CTL_chromaticities_blue_y_i(Fl_Value_Input* o, mrv::PreferencesUI* v) {
  mrv::Preferences::ODT_CTL_chromaticities.green.x = (float) o->value();
v->refresh();
}
void PreferencesUI::cb_uiODT_CTL_chromaticities_blue_y(Fl_Value_Input* o, mrv::PreferencesUI* v) {
  ((PreferencesUI*)(o->parent()->parent()->parent()->parent()->parent()->parent()->parent()->user_data()))->cb_uiODT_CTL_chromaticities_blue_y_i(o,v);
}

void PreferencesUI::cb_uiODT_CTL_chromaticities_white_x_i(Fl_Value_Input* o, mrv::PreferencesUI* v) {
  mrv::Preferences::ODT_CTL_chromaticities.green.x = (float) o->value();
v->refresh();
}
void PreferencesUI::cb_uiODT_CTL_chromaticities_white_x(Fl_Value_Input* o, mrv::PreferencesUI* v) {
  ((PreferencesUI*)(o->parent()->parent()->parent()->parent()->parent()->parent()->parent()->user_data()))->cb_uiODT_CTL_chromaticities_white_x_i(o,v);
}

void PreferencesUI::cb_uiODT_CTL_chromaticities_white_y_i(Fl_Value_Input* o, mrv::PreferencesUI* v) {
  mrv::Preferences::ODT_CTL_chromaticities.white.y = (float) o->value();
v->refresh();
}
void PreferencesUI::cb_uiODT_CTL_chromaticities_white_y(Fl_Value_Input* o, mrv::PreferencesUI* v) {
  ((PreferencesUI*)(o->parent()->parent()->parent()->parent()->parent()->parent()->parent()->user_data()))->cb_uiODT_CTL_chromaticities_white_y_i(o,v);
}

void PreferencesUI::cb_uiODT_CTL_white_luminance_i(Fl_Value_Input* o, mrv::PreferencesUI* v) {
  mrv::Preferences::ODT_CTL_white_luminance = (float) o->value();
v->refresh();
}
void PreferencesUI::cb_uiODT_CTL_white_luminance(Fl_Value_Input* o, mrv::PreferencesUI* v) {
  ((PreferencesUI*)(o->parent()->parent()->parent()->parent()->parent()->parent()->user_data()))->cb_uiODT_CTL_white_luminance_i(o,v);
}

void PreferencesUI::cb_uiODT_CTL_surround_luminance_i(Fl_Value_Input* o, mrv::PreferencesUI* v) {
  mrv::Preferences::ODT_CTL_surround_luminance = (float) o->value();
v->refresh();
}
void PreferencesUI::cb_uiODT_CTL_surround_luminance(Fl_Value_Input* o, mrv::PreferencesUI* v) {
  ((PreferencesUI*)(o->parent()->parent()->parent()->parent()->parent()->parent()->user_data()))->cb_uiODT_CTL_surround_luminance_i(o,v);
}

void PreferencesUI::cb_uiODT_ICC_profile_i(Fl_Input* o, mrv::PreferencesUI* v) {
  mrv::Preferences::ODT_ICC_profile = o->text();
v->refresh();
}
void PreferencesUI::cb_uiODT_ICC_profile(Fl_Input* o, mrv::PreferencesUI* v) {
  ((PreferencesUI*)(o->parent()->parent()->parent()->parent()->parent()->user_data()))->cb_uiODT_ICC_profile_i(o,v);
}

void PreferencesUI::cb_Load_i(Fl_Button*, mrv::PreferencesUI*) {
  const char* c = open_icc_profile(uiODT_ICC_profile->text());
uiODT_ICC_profile->text(c);
uiODT_ICC_profile->do_callback();
}
void PreferencesUI::cb_Load(Fl_Button* o, mrv::PreferencesUI* v) {
  ((PreferencesUI*)(o->parent()->parent()->parent()->parent()->parent()->user_data()))->cb_Load_i(o,v);
}

void PreferencesUI::cb_uiCTL_8bits_load_transform_i(Fl_Input* o, mrv::PreferencesUI* v) {
  mrv::CMedia::rendering_transform_8bits = o->text();
v->refresh();
}
void PreferencesUI::cb_uiCTL_8bits_load_transform(Fl_Input* o, mrv::PreferencesUI* v) {
  ((PreferencesUI*)(o->parent()->parent()->parent()->parent()->parent()->user_data()))->cb_uiCTL_8bits_load_transform_i(o,v);
}

void PreferencesUI::cb_Pick1_i(Fl_Button*, mrv::PreferencesUI*) {
  std::string c = make_ctl_browser(uiCTL_8bits_load_transform->text(), "RRT");
if (c.empty()) return;
uiCTL_8bits_load_transform->text(c.c_str());
uiCTL_8bits_load_transform->do_callback();
}
void PreferencesUI::cb_Pick1(Fl_Button* o, mrv::PreferencesUI* v) {
  ((PreferencesUI*)(o->parent()->parent()->parent()->parent()->parent()->user_data()))->cb_Pick1_i(o,v);
}

void PreferencesUI::cb_uiCTL_16bits_load_transform_i(Fl_Input* o, mrv::PreferencesUI* v) {
  mrv::CMedia::rendering_transform_16bits = o->text();
v->refresh();
}
void PreferencesUI::cb_uiCTL_16bits_load_transform(Fl_Input* o, mrv::PreferencesUI* v) {
  ((PreferencesUI*)(o->parent()->parent()->parent()->parent()->parent()->user_data()))->cb_uiCTL_16bits_load_transform_i(o,v);
}

void PreferencesUI::cb_Pick2_i(Fl_Button*, mrv::PreferencesUI*) {
  std::string c = make_ctl_browser(uiCTL_16bits_load_transform->text(), "RRT");
if (c.empty()) return;
uiCTL_16bits_load_transform->text(c.c_str());
uiCTL_16bits_load_transform->do_callback();
}
void PreferencesUI::cb_Pick2(Fl_Button* o, mrv::PreferencesUI* v) {
  ((PreferencesUI*)(o->parent()->parent()->parent()->parent()->parent()->user_data()))->cb_Pick2_i(o,v);
}

void PreferencesUI::cb_uiCTL_32bits_load_transform_i(Fl_Input* o, mrv::PreferencesUI* v) {
  mrv::CMedia::rendering_transform_32bits = o->text();
v->refresh();
}
void PreferencesUI::cb_uiCTL_32bits_load_transform(Fl_Input* o, mrv::PreferencesUI* v) {
  ((PreferencesUI*)(o->parent()->parent()->parent()->parent()->parent()->user_data()))->cb_uiCTL_32bits_load_transform_i(o,v);
}

void PreferencesUI::cb_Pick3_i(Fl_Button*, mrv::PreferencesUI*) {
  std::string c = make_ctl_browser(uiCTL_16bits_load_transform->text(), "RRT");
if (c.empty()) return;
uiCTL_16bits_load_transform->text(c.c_str());
uiCTL_16bits_load_transform->do_callback();
}
void PreferencesUI::cb_Pick3(Fl_Button* o, mrv::PreferencesUI* v) {
  ((PreferencesUI*)(o->parent()->parent()->parent()->parent()->parent()->user_data()))->cb_Pick3_i(o,v);
}

void PreferencesUI::cb_uiCTL_float_load_transform_i(Fl_Input* o, mrv::PreferencesUI* v) {
  mrv::CMedia::rendering_transform_float = o->text();
v->refresh();
}
void PreferencesUI::cb_uiCTL_float_load_transform(Fl_Input* o, mrv::PreferencesUI* v) {
  ((PreferencesUI*)(o->parent()->parent()->parent()->parent()->parent()->user_data()))->cb_uiCTL_float_load_transform_i(o,v);
}

void PreferencesUI::cb_Pick4_i(Fl_Button*, mrv::PreferencesUI*) {
  std::string c = make_ctl_browser(uiCTL_float_load_transform->text(), "RRT");
if (c.empty()) return;
uiCTL_float_load_transform->text(c.c_str());
uiCTL_float_load_transform->do_callback();
}
void PreferencesUI::cb_Pick4(Fl_Button* o, mrv::PreferencesUI* v) {
  ((PreferencesUI*)(o->parent()->parent()->parent()->parent()->parent()->user_data()))->cb_Pick4_i(o,v);
}

void PreferencesUI::cb_uiICC_8bits_profile_i(Fl_Input* o, mrv::PreferencesUI* v) {
  mrv::CMedia::icc_profile_8bits = o->text();
v->refresh();
}
void PreferencesUI::cb_uiICC_8bits_profile(Fl_Input* o, mrv::PreferencesUI* v) {
  ((PreferencesUI*)(o->parent()->parent()->parent()->parent()->parent()->user_data()))->cb_uiICC_8bits_profile_i(o,v);
}

void PreferencesUI::cb_Load1_i(Fl_Button*, mrv::PreferencesUI*) {
  const char* c = open_icc_profile(uiICC_8bits_profile->text());
uiICC_8bits_profile->text(c);
uiICC_8bits_profile->do_callback();
}
void PreferencesUI::cb_Load1(Fl_Button* o, mrv::PreferencesUI* v) {
  ((PreferencesUI*)(o->parent()->parent()->parent()->parent()->parent()->user_data()))->cb_Load1_i(o,v);
}

void PreferencesUI::cb_uiICC_16bits_profile_i(Fl_Input* o, mrv::PreferencesUI* v) {
  mrv::CMedia::icc_profile_16bits = o->text();
v->refresh();
}
void PreferencesUI::cb_uiICC_16bits_profile(Fl_Input* o, mrv::PreferencesUI* v) {
  ((PreferencesUI*)(o->parent()->parent()->parent()->parent()->parent()->user_data()))->cb_uiICC_16bits_profile_i(o,v);
}

void PreferencesUI::cb_Load2_i(Fl_Button*, mrv::PreferencesUI*) {
  const char* c = open_icc_profile(uiICC_16bits_profile->text());
uiICC_16bits_profile->text(c);
uiICC_16bits_profile->do_callback();
}
void PreferencesUI::cb_Load2(Fl_Button* o, mrv::PreferencesUI* v) {
  ((PreferencesUI*)(o->parent()->parent()->parent()->parent()->parent()->user_data()))->cb_Load2_i(o,v);
}

void PreferencesUI::cb_uiICC_32bits_profile_i(Fl_Input* o, mrv::PreferencesUI* v) {
  mrv::CMedia::icc_profile_32bits = o->text();
v->refresh();
}
void PreferencesUI::cb_uiICC_32bits_profile(Fl_Input* o, mrv::PreferencesUI* v) {
  ((PreferencesUI*)(o->parent()->parent()->parent()->parent()->parent()->user_data()))->cb_uiICC_32bits_profile_i(o,v);
}

void PreferencesUI::cb_Load3_i(Fl_Button*, mrv::PreferencesUI*) {
  const char* c = open_icc_profile(uiICC_32bits_profile->text());
uiICC_32bits_profile->text(c);
uiICC_32bits_profile->do_callback();
}
void PreferencesUI::cb_Load3(Fl_Button* o, mrv::PreferencesUI* v) {
  ((PreferencesUI*)(o->parent()->parent()->parent()->parent()->parent()->user_data()))->cb_Load3_i(o,v);
}

void PreferencesUI::cb_uiICC_float_profile_i(Fl_Input* o, mrv::PreferencesUI* v) {
  mrv::CMedia::icc_profile_float = o->text();
v->refresh();
}
void PreferencesUI::cb_uiICC_float_profile(Fl_Input* o, mrv::PreferencesUI* v) {
  ((PreferencesUI*)(o->parent()->parent()->parent()->parent()->parent()->user_data()))->cb_uiICC_float_profile_i(o,v);
}

void PreferencesUI::cb_Load4_i(Fl_Button*, mrv::PreferencesUI*) {
  const char* c = open_icc_profile(uiICC_float_profile->text());
uiICC_float_profile->text(c);
uiICC_float_profile->do_callback();
}
void PreferencesUI::cb_Load4(Fl_Button* o, mrv::PreferencesUI* v) {
  ((PreferencesUI*)(o->parent()->parent()->parent()->parent()->parent()->user_data()))->cb_Load4_i(o,v);
}

Fl_Menu_Item PreferencesUI::menu_VideoDriver[] = {
 {"OpenGL", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0}
};

Fl_Menu_Item PreferencesUI::menu_uiPrefsBlendMode[] = {
 {"Traditional", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Premult", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Traditional No Gamma", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Premult No Gamma", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0}
};

void PreferencesUI::cb_uiPrefsAudioMute_i(Fl_Button* o, fltk::Slider* v) {
  o->value( !o->value() );
if ( o->value() )
   v->deactivate();
else
   v->activate();
}
void PreferencesUI::cb_uiPrefsAudioMute(Fl_Button* o, fltk::Slider* v) {
  ((PreferencesUI*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_uiPrefsAudioMute_i(o,v);
}

void PreferencesUI::cb_uiPrefsOpenEXRCompression_i(Fl_Choice* o, mrv::PreferencesUI* v) {
  std::string compression = o->child(o->value())->label();
if ( compression == "DWAA" ||
     compression == "DWAB" )
{
v->uiPrefsOpenEXRDWACompression->activate();
}
else
{
v->uiPrefsOpenEXRDWACompression->deactivate();
};
}
void PreferencesUI::cb_uiPrefsOpenEXRCompression(Fl_Choice* o, mrv::PreferencesUI* v) {
  ((PreferencesUI*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_uiPrefsOpenEXRCompression_i(o,v);
}

Fl_Menu_Item PreferencesUI::menu_uiPrefsOpenEXRCompression[] = {
 {"None", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"RLE", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"ZIP SCANLINE", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"ZIP", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"PIZ", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"PXR24", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"B44", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"B44A", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"DWAA", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"DWAB", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0}
};

void PreferencesUI::cb_Module_i(mrv::PreferencesBrowser* o, mrv::PreferencesUI* v) {
  o->update( v );
}
void PreferencesUI::cb_Module(mrv::PreferencesBrowser* o, mrv::PreferencesUI* v) {
  ((PreferencesUI*)(o->parent()->parent()->user_data()))->cb_Module_i(o,v);
}

void PreferencesUI::cb_Revert_i(Fl_Button*, mrv::PreferencesUI* v) {
  // reload preferences
mrv::Preferences prefs(v);
}
void PreferencesUI::cb_Revert(Fl_Button* o, mrv::PreferencesUI* v) {
  ((PreferencesUI*)(o->parent()->parent()->user_data()))->cb_Revert_i(o,v);
}

void PreferencesUI::cb_Save_i(Fl_Button*, void*) {
  mrv::Preferences::save();
}
void PreferencesUI::cb_Save(Fl_Button* o, void* v) {
  ((PreferencesUI*)(o->parent()->parent()->user_data()))->cb_Save_i(o,v);
}

void PreferencesUI::cb_OK_i(Fl_Button*, mrv::ViewerUI* v) {
  v->uiPrefs->uiMain->hide();
v->uiPrefs->run(v);
}
void PreferencesUI::cb_OK(Fl_Button* o, mrv::ViewerUI* v) {
  ((PreferencesUI*)(o->parent()->parent()->user_data()))->cb_OK_i(o,v);
}

Fl_Double_Window* PreferencesUI::make_window(mrv::ViewerUI* m) {
  { uiMain = new Fl_Double_Window(670, 450, "Preferences");
    uiMain->user_data((void*)(this));
    { uiWizard = new Fl_Wizard(218, 24, 452, 400, "Settings");
      { Fl_Group* o = new Fl_Group(231, 46, 427, 364, "User Interface");
        o->box(FL_EMBOSSED_BOX);
        o->align(Fl_Align(FL_ALIGN_TOP_LEFT));
        o->hide();
        { Fl_Group* o = new Fl_Group(240, 78, 410, 100, "Window Behavior");
          o->box(FL_ROUNDED_BOX);
          { uiPrefsAlwaysOnTop = new Fl_Check_Button(264, 92, 19, 25, "Always on Top");
            uiPrefsAlwaysOnTop->tooltip("When selected, mrViewer\'s window will always show up on top of other windows\
 on the desktop.");
            uiPrefsAlwaysOnTop->box(FL_UP_BOX);
            uiPrefsAlwaysOnTop->down_box(FL_DOWN_BOX);
            uiPrefsAlwaysOnTop->value(1);
            uiPrefsAlwaysOnTop->align(Fl_Align(FL_ALIGN_RIGHT));
          } // Fl_Check_Button* uiPrefsAlwaysOnTop
          { uiPrefsSingleInstance = new Fl_Check_Button(264, 118, 20, 25, "Single Instance");
            uiPrefsSingleInstance->tooltip("When selected, only a single mrViewer instance is allowed.  \nIf you try to o\
pen several mrViewers with different images, all these images will be sent to \
the already open mrViewer.");
            uiPrefsSingleInstance->box(FL_UP_BOX);
            uiPrefsSingleInstance->down_box(FL_DOWN_BOX);
            uiPrefsSingleInstance->value(1);
            uiPrefsSingleInstance->align(Fl_Align(FL_ALIGN_RIGHT));
          } // Fl_Check_Button* uiPrefsSingleInstance
          { uiPrefsAutoFitImage = new Fl_Check_Button(264, 145, 20, 25, "Auto Refit Image");
            uiPrefsAutoFitImage->tooltip("When selected, mrViewer will apply a fit image operation on each video played\
.  This effectly means the video will be resized automatically based on the si\
ze of the window.");
            uiPrefsAutoFitImage->box(FL_UP_BOX);
            uiPrefsAutoFitImage->down_box(FL_DOWN_BOX);
            uiPrefsAutoFitImage->value(1);
            uiPrefsAutoFitImage->align(Fl_Align(FL_ALIGN_RIGHT));
          } // Fl_Check_Button* uiPrefsAutoFitImage
          { uiPrefsOpenMode = new Fl_Group(437, 87, 150, 81);
            uiPrefsOpenMode->box(FL_UP_BOX);
            { Fl_Round_Button* o = new Fl_Round_Button(452, 93, 19, 20, "Normal");
              o->tooltip("When selected, mrViewer will resize its window to the first image.");
              o->box(FL_ROUND_UP_BOX);
              o->down_box(FL_ROUND_DOWN_BOX);
              o->value(1);
              o->align(Fl_Align(FL_ALIGN_RIGHT));
            } // Fl_Round_Button* o
            { Fl_Round_Button* o = new Fl_Round_Button(452, 118, 19, 20, "Fullscreen");
              o->tooltip("When selected, mrViewer will start in full screen mode.");
              o->box(FL_ROUND_UP_BOX);
              o->down_box(FL_ROUND_DOWN_BOX);
              o->align(Fl_Align(FL_ALIGN_RIGHT));
            } // Fl_Round_Button* o
            { Fl_Round_Button* o = new Fl_Round_Button(452, 143, 19, 20, "Presentation");
              o->tooltip("When selected, mrViewer will start in presentation mode.");
              o->box(FL_ROUND_UP_BOX);
              o->down_box(FL_ROUND_DOWN_BOX);
              o->align(Fl_Align(FL_ALIGN_RIGHT));
            } // Fl_Round_Button* o
            uiPrefsOpenMode->end();
          } // Fl_Group* uiPrefsOpenMode
          o->end();
        } // Fl_Group* o
        { Fl_Group* o = new Fl_Group(240, 207, 410, 98, "UI Elements");
          o->box(FL_ROUNDED_BOX);
          { uiPrefsTopbar = new Fl_Check_Button(245, 212, 25, 25, "Topbar");
            uiPrefsTopbar->tooltip("When selected, mrViewer will start with its channel, gain, gamma toolbar visi\
ble.");
            uiPrefsTopbar->box(FL_UP_BOX);
            uiPrefsTopbar->down_box(FL_DOWN_BOX);
            uiPrefsTopbar->value(1);
            uiPrefsTopbar->align(Fl_Align(FL_ALIGN_RIGHT));
          } // Fl_Check_Button* uiPrefsTopbar
          { uiPrefsPixelToolbar = new Fl_Check_Button(245, 243, 25, 25, "Pixel Toolbar");
            uiPrefsPixelToolbar->tooltip("When selected, mrViewer will start with the pixel toolbar shown.");
            uiPrefsPixelToolbar->box(FL_UP_BOX);
            uiPrefsPixelToolbar->down_box(FL_DOWN_BOX);
            uiPrefsPixelToolbar->value(1);
            uiPrefsPixelToolbar->align(Fl_Align(FL_ALIGN_RIGHT));
          } // Fl_Check_Button* uiPrefsPixelToolbar
          { uiPrefsTimeline = new Fl_Check_Button(245, 273, 25, 25, "Timeline");
            uiPrefsTimeline->tooltip("When selected, mrViewer will start with the timeline shown.");
            uiPrefsTimeline->box(FL_UP_BOX);
            uiPrefsTimeline->down_box(FL_DOWN_BOX);
            uiPrefsTimeline->value(1);
            uiPrefsTimeline->align(Fl_Align(FL_ALIGN_RIGHT));
          } // Fl_Check_Button* uiPrefsTimeline
          { uiPrefsReelList = new Fl_Check_Button(380, 212, 25, 25, "Reel List");
            uiPrefsReelList->tooltip("When selected, mrViewer will start with the reel list already open.");
            uiPrefsReelList->box(FL_UP_BOX);
            uiPrefsReelList->down_box(FL_DOWN_BOX);
            uiPrefsReelList->align(Fl_Align(FL_ALIGN_RIGHT));
          } // Fl_Check_Button* uiPrefsReelList
          { uiPrefsHistogram = new Fl_Check_Button(515, 243, 25, 25, "Histogram");
            uiPrefsHistogram->tooltip("When selected, mrViewer will start with the histogram already open.");
            uiPrefsHistogram->box(FL_UP_BOX);
            uiPrefsHistogram->down_box(FL_DOWN_BOX);
            uiPrefsHistogram->align(Fl_Align(FL_ALIGN_RIGHT));
          } // Fl_Check_Button* uiPrefsHistogram
          { uiPrefsVectorscope = new Fl_Check_Button(515, 273, 25, 25, "Vectorscope");
            uiPrefsVectorscope->tooltip("When selected, mrViewer will start with the vectorscope already open.");
            uiPrefsVectorscope->box(FL_UP_BOX);
            uiPrefsVectorscope->down_box(FL_DOWN_BOX);
            uiPrefsVectorscope->align(Fl_Align(FL_ALIGN_RIGHT));
          } // Fl_Check_Button* uiPrefsVectorscope
          { uiPrefsImageInfo = new Fl_Check_Button(380, 243, 25, 25, "Media Info");
            uiPrefsImageInfo->tooltip("When selected, mrViewer will start with the media information window already \
open.");
            uiPrefsImageInfo->box(FL_UP_BOX);
            uiPrefsImageInfo->down_box(FL_DOWN_BOX);
            uiPrefsImageInfo->align(Fl_Align(FL_ALIGN_RIGHT));
          } // Fl_Check_Button* uiPrefsImageInfo
          { uiPrefsColorArea = new Fl_Check_Button(380, 273, 25, 25, "Color Area");
            uiPrefsColorArea->tooltip("When selected, mrViewer will start with the color area window already open.");
            uiPrefsColorArea->box(FL_UP_BOX);
            uiPrefsColorArea->down_box(FL_DOWN_BOX);
            uiPrefsColorArea->align(Fl_Align(FL_ALIGN_RIGHT));
          } // Fl_Check_Button* uiPrefsColorArea
          { uiPrefsEDLEdit = new Fl_Check_Button(515, 215, 25, 25, "EDL Edit");
            uiPrefsEDLEdit->tooltip("When selected, mrViewer will start with the histogram already open.");
            uiPrefsEDLEdit->box(FL_UP_BOX);
            uiPrefsEDLEdit->down_box(FL_DOWN_BOX);
            uiPrefsEDLEdit->align(Fl_Align(FL_ALIGN_RIGHT));
          } // Fl_Check_Button* uiPrefsEDLEdit
          o->end();
        } // Fl_Group* o
        { Fl_Group* o = new Fl_Group(240, 328, 410, 70, "Timeline");
          o->box(FL_ROUNDED_BOX);
          { Fl_Choice* o = uiPrefsTimelineDisplay = new Fl_Choice(345, 353, 190, 25, "Display");
            uiPrefsTimelineDisplay->tooltip("How to display timeline by default.");
            uiPrefsTimelineDisplay->box(FL_THIN_DOWN_BOX);
            uiPrefsTimelineDisplay->down_box(FL_BORDER_BOX);
            uiPrefsTimelineDisplay->menu(menu_uiPrefsTimelineDisplay);
            o->value(0);
          } // Fl_Choice* uiPrefsTimelineDisplay
          o->end();
        } // Fl_Group* o
        o->end();
      } // Fl_Group* o
      { Fl_Group* o = new Fl_Group(233, 46, 425, 377, "View Window");
        o->box(FL_EMBOSSED_BOX);
        o->align(Fl_Align(FL_ALIGN_TOP_LEFT));
        o->hide();
        { Fl_Group* o = new Fl_Group(246, 78, 394, 135, "Defaults");
          o->box(FL_ROUNDED_BOX);
          { uiPrefsViewGain = new Fl_Value_Input(336, 88, 80, 25, "Gain");
            uiPrefsViewGain->tooltip("Sets the default gain when mrViewer starts.");
            uiPrefsViewGain->minimum(0.001);
            uiPrefsViewGain->maximum(64);
            uiPrefsViewGain->step(0.01);
            uiPrefsViewGain->value(1);
          } // Fl_Value_Input* uiPrefsViewGain
          { uiPrefsViewGamma = new Fl_Value_Input(526, 88, 60, 25, "Gamma");
            uiPrefsViewGamma->tooltip("Sets the default gamma when mrViewer starts.");
            uiPrefsViewGamma->minimum(0.01);
            uiPrefsViewGamma->maximum(4);
            uiPrefsViewGamma->step(0.01);
            uiPrefsViewGamma->value(1);
          } // Fl_Value_Input* uiPrefsViewGamma
          { uiPrefsCropArea = new Fl_Choice(261, 136, 155, 25, "Crop");
            uiPrefsCropArea->tooltip("Allows you to select a standard cropping area around image.");
            uiPrefsCropArea->box(FL_THIN_DOWN_BOX);
            uiPrefsCropArea->down_box(FL_BORDER_BOX);
            uiPrefsCropArea->user_data((void*)(this));
            uiPrefsCropArea->align(Fl_Align(FL_ALIGN_TOP));
            uiPrefsCropArea->menu(menu_uiPrefsCropArea);
          } // Fl_Choice* uiPrefsCropArea
          { uiPrefsViewPixelRatio = new Fl_Check_Button(444, 133, 20, 22, "Compensate Pixel Ratio");
            uiPrefsViewPixelRatio->tooltip("When mrViewer starts, the pixel aspect ratio compensation will be active by d\
efault.");
            uiPrefsViewPixelRatio->box(FL_UP_BOX);
            uiPrefsViewPixelRatio->down_box(FL_DOWN_BOX);
            uiPrefsViewPixelRatio->align(Fl_Align(FL_ALIGN_RIGHT));
          } // Fl_Check_Button* uiPrefsViewPixelRatio
          { uiPrefsViewLut = new Fl_Check_Button(444, 158, 20, 22, "Lut Active");
            uiPrefsViewLut->tooltip("When mrViewer starts, the 3D Lut will be active.");
            uiPrefsViewLut->box(FL_UP_BOX);
            uiPrefsViewLut->down_box(FL_DOWN_BOX);
            uiPrefsViewLut->user_data((void*)(this));
            uiPrefsViewLut->align(Fl_Align(FL_ALIGN_RIGHT));
          } // Fl_Check_Button* uiPrefsViewLut
          { uiPrefsSafeAreas = new Fl_Check_Button(444, 185, 20, 20, "Safe Areas");
            uiPrefsSafeAreas->tooltip("When mrViewer starts, the safe area display will be active by default.");
            uiPrefsSafeAreas->box(FL_UP_BOX);
            uiPrefsSafeAreas->down_box(FL_DOWN_BOX);
            uiPrefsSafeAreas->user_data((void*)(this));
            uiPrefsSafeAreas->align(Fl_Align(FL_ALIGN_RIGHT));
          } // Fl_Check_Button* uiPrefsSafeAreas
          { uiPrefsViewDisplayWindow = new Fl_Check_Button(266, 166, 20, 22, "Display Window");
            uiPrefsViewDisplayWindow->tooltip("When mrViewer starts, the display window will be shown when appropiate.");
            uiPrefsViewDisplayWindow->box(FL_UP_BOX);
            uiPrefsViewDisplayWindow->down_box(FL_DOWN_BOX);
            uiPrefsViewDisplayWindow->value(1);
            uiPrefsViewDisplayWindow->align(Fl_Align(FL_ALIGN_RIGHT));
          } // Fl_Check_Button* uiPrefsViewDisplayWindow
          { uiPrefsViewDataWindow = new Fl_Check_Button(266, 186, 20, 22, "Data Window");
            uiPrefsViewDataWindow->tooltip("When mrViewer starts, the data window will be shown when appropiate as a dott\
ed line.");
            uiPrefsViewDataWindow->box(FL_UP_BOX);
            uiPrefsViewDataWindow->down_box(FL_DOWN_BOX);
            uiPrefsViewDataWindow->value(1);
            uiPrefsViewDataWindow->align(Fl_Align(FL_ALIGN_RIGHT));
          } // Fl_Check_Button* uiPrefsViewDataWindow
          o->end();
        } // Fl_Group* o
        { uiPrefsHud = new Fl_Group(248, 233, 397, 122, "HUD");
          uiPrefsHud->tooltip("This area specifies which elements should be shown as a HUD overlay on the vi\
ew screen.");
          uiPrefsHud->box(FL_UP_BOX);
          uiPrefsHud->user_data((void*)(this));
          { uiPrefsHudFilename = new Fl_Check_Button(400, 320, 20, 20, "Filename");
            uiPrefsHudFilename->box(FL_UP_BOX);
            uiPrefsHudFilename->down_box(FL_DOWN_BOX);
            uiPrefsHudFilename->user_data((void*)(this));
            uiPrefsHudFilename->align(Fl_Align(FL_ALIGN_RIGHT));
          } // Fl_Check_Button* uiPrefsHudFilename
          { uiPrefsHudDirectory = new Fl_Check_Button(400, 294, 20, 20, "Directory");
            uiPrefsHudDirectory->box(FL_UP_BOX);
            uiPrefsHudDirectory->down_box(FL_DOWN_BOX);
            uiPrefsHudDirectory->user_data((void*)(this));
            uiPrefsHudDirectory->align(Fl_Align(FL_ALIGN_RIGHT));
          } // Fl_Check_Button* uiPrefsHudDirectory
          { uiPrefsHudFrame = new Fl_Check_Button(264, 268, 20, 20, "Frame");
            uiPrefsHudFrame->box(FL_UP_BOX);
            uiPrefsHudFrame->down_box(FL_DOWN_BOX);
            uiPrefsHudFrame->user_data((void*)(this));
            uiPrefsHudFrame->align(Fl_Align(FL_ALIGN_RIGHT));
          } // Fl_Check_Button* uiPrefsHudFrame
          { uiPrefsHudFrameRange = new Fl_Check_Button(263, 295, 20, 20, "Frame Range");
            uiPrefsHudFrameRange->box(FL_UP_BOX);
            uiPrefsHudFrameRange->down_box(FL_DOWN_BOX);
            uiPrefsHudFrameRange->user_data((void*)(this));
            uiPrefsHudFrameRange->align(Fl_Align(FL_ALIGN_RIGHT));
          } // Fl_Check_Button* uiPrefsHudFrameRange
          { uiPrefsHudResolution = new Fl_Check_Button(400, 243, 20, 20, "Resolution");
            uiPrefsHudResolution->box(FL_UP_BOX);
            uiPrefsHudResolution->down_box(FL_DOWN_BOX);
            uiPrefsHudResolution->user_data((void*)(this));
            uiPrefsHudResolution->align(Fl_Align(FL_ALIGN_RIGHT));
          } // Fl_Check_Button* uiPrefsHudResolution
          { uiPrefsHudFPS = new Fl_Check_Button(264, 243, 20, 20, "FPS");
            uiPrefsHudFPS->box(FL_UP_BOX);
            uiPrefsHudFPS->down_box(FL_DOWN_BOX);
            uiPrefsHudFPS->user_data((void*)(this));
            uiPrefsHudFPS->align(Fl_Align(FL_ALIGN_RIGHT));
          } // Fl_Check_Button* uiPrefsHudFPS
          { uiPrefsHudIPTC = new Fl_Check_Button(520, 244, 20, 20, "IPTC Data");
            uiPrefsHudIPTC->box(FL_UP_BOX);
            uiPrefsHudIPTC->down_box(FL_DOWN_BOX);
            uiPrefsHudIPTC->user_data((void*)(this));
            uiPrefsHudIPTC->align(Fl_Align(FL_ALIGN_RIGHT));
          } // Fl_Check_Button* uiPrefsHudIPTC
          { uiPrefsHudAVDifference = new Fl_Check_Button(400, 268, 20, 20, "VA Difference");
            uiPrefsHudAVDifference->box(FL_UP_BOX);
            uiPrefsHudAVDifference->down_box(FL_DOWN_BOX);
            uiPrefsHudAVDifference->user_data((void*)(this));
            uiPrefsHudAVDifference->align(Fl_Align(FL_ALIGN_RIGHT));
          } // Fl_Check_Button* uiPrefsHudAVDifference
          { uiPrefsHudTimecode = new Fl_Check_Button(263, 320, 20, 20, "Timecode");
            uiPrefsHudTimecode->box(FL_UP_BOX);
            uiPrefsHudTimecode->down_box(FL_DOWN_BOX);
            uiPrefsHudTimecode->user_data((void*)(this));
            uiPrefsHudTimecode->align(Fl_Align(FL_ALIGN_RIGHT));
          } // Fl_Check_Button* uiPrefsHudTimecode
          { uiPrefsHudWipeMode = new Fl_Check_Button(521, 269, 20, 20, "Wipe Mode");
            uiPrefsHudWipeMode->box(FL_UP_BOX);
            uiPrefsHudWipeMode->down_box(FL_DOWN_BOX);
            uiPrefsHudWipeMode->user_data((void*)(this));
            uiPrefsHudWipeMode->align(Fl_Align(FL_ALIGN_RIGHT));
          } // Fl_Check_Button* uiPrefsHudWipeMode
          { uiPrefsHudMemory = new Fl_Check_Button(521, 295, 20, 20, "Memory");
            uiPrefsHudMemory->box(FL_UP_BOX);
            uiPrefsHudMemory->down_box(FL_DOWN_BOX);
            uiPrefsHudMemory->user_data((void*)(this));
            uiPrefsHudMemory->align(Fl_Align(FL_ALIGN_RIGHT));
          } // Fl_Check_Button* uiPrefsHudMemory
          uiPrefsHud->end();
        } // Fl_Group* uiPrefsHud
        { Fl_Group* o = new Fl_Group(251, 370, 355, 40, "Positioning");
          o->box(FL_ROUNDED_BOX);
          { uiWindowFixedPosition = new Fl_Check_Button(271, 380, 100, 20, "Fixed Position");
            uiWindowFixedPosition->box(FL_UP_BOX);
            uiWindowFixedPosition->down_box(FL_DOWN_BOX);
          } // Fl_Check_Button* uiWindowFixedPosition
          { uiWindowXPosition = new Fl_Value_Input(431, 375, 60, 25, "X:");
          } // Fl_Value_Input* uiWindowXPosition
          { uiWindowYPosition = new Fl_Value_Input(511, 375, 60, 25, "Y:");
          } // Fl_Value_Input* uiWindowYPosition
          o->end();
        } // Fl_Group* o
        o->end();
      } // Fl_Group* o
      { Fl_Group* o = new Fl_Group(233, 46, 425, 360, "Colors");
        o->box(FL_EMBOSSED_BOX);
        o->align(Fl_Align(FL_ALIGN_TOP_LEFT));
        o->hide();
        { Fl_Group* o = new Fl_Group(245, 70, 383, 108, "UI");
          o->box(FL_ROUNDED_BOX);
          { uiPrefsUIBG = new Fl_Button(386, 88, 25, 25, "Background");
            uiPrefsUIBG->tooltip("Selects the background of UI.");
            uiPrefsUIBG->box(FL_EMBOSSED_BOX);
            uiPrefsUIBG->labelsize(11);
            uiPrefsUIBG->callback((Fl_Callback*)cb_uiPrefsUIBG);
            uiPrefsUIBG->align(Fl_Align(FL_ALIGN_LEFT));
          } // Fl_Button* uiPrefsUIBG
          { uiPrefsUIText = new Fl_Button(386, 133, 25, 25, "Text");
            uiPrefsUIText->tooltip("Selects the color of text in widgets.");
            uiPrefsUIText->box(FL_EMBOSSED_BOX);
            uiPrefsUIText->labelsize(11);
            uiPrefsUIText->callback((Fl_Callback*)cb_uiPrefsUIText, (void*)(this));
            uiPrefsUIText->align(Fl_Align(FL_ALIGN_LEFT));
          } // Fl_Button* uiPrefsUIText
          { uiPrefsUISelection = new Fl_Button(501, 88, 25, 25, "Selection");
            uiPrefsUISelection->tooltip("Selects the color of the selection rectangle in widgets.");
            uiPrefsUISelection->box(FL_EMBOSSED_BOX);
            uiPrefsUISelection->labelsize(11);
            uiPrefsUISelection->callback((Fl_Callback*)cb_uiPrefsUISelection, (void*)(this));
            uiPrefsUISelection->align(Fl_Align(FL_ALIGN_LEFT));
          } // Fl_Button* uiPrefsUISelection
          { uiPrefsUISelectionText = new Fl_Button(501, 133, 25, 25, "Selected Text");
            uiPrefsUISelectionText->tooltip("Selects the color of text in widgets.");
            uiPrefsUISelectionText->box(FL_EMBOSSED_BOX);
            uiPrefsUISelectionText->labelsize(11);
            uiPrefsUISelectionText->callback((Fl_Callback*)cb_uiPrefsUISelectionText, (void*)(this));
            uiPrefsUISelectionText->align(Fl_Align(FL_ALIGN_LEFT));
          } // Fl_Button* uiPrefsUISelectionText
          o->end();
        } // Fl_Group* o
        { Fl_Group* o = new Fl_Group(245, 220, 383, 108, "View");
          o->box(FL_ROUNDED_BOX);
          { uiPrefsViewBG = new Fl_Button(408, 250, 25, 25, "Background");
            uiPrefsViewBG->tooltip("Selects the background color of areas outside the current image.");
            uiPrefsViewBG->box(FL_EMBOSSED_BOX);
            uiPrefsViewBG->labelsize(11);
            uiPrefsViewBG->callback((Fl_Callback*)cb_uiPrefsViewBG);
            uiPrefsViewBG->align(Fl_Align(FL_ALIGN_LEFT));
          } // Fl_Button* uiPrefsViewBG
          { uiPrefsViewTextOverlay = new Fl_Button(408, 280, 25, 25, "Text Overlay");
            uiPrefsViewTextOverlay->tooltip("Selects the color of text overlays printed over the current image.");
            uiPrefsViewTextOverlay->box(FL_EMBOSSED_BOX);
            uiPrefsViewTextOverlay->labelsize(11);
            uiPrefsViewTextOverlay->callback((Fl_Callback*)cb_uiPrefsViewTextOverlay, (void*)(this));
            uiPrefsViewTextOverlay->align(Fl_Align(FL_ALIGN_LEFT));
          } // Fl_Button* uiPrefsViewTextOverlay
          { uiPrefsViewSelection = new Fl_Button(523, 250, 25, 25, "Selection");
            uiPrefsViewSelection->tooltip("Selects the color of the selection rectangle over the current image.");
            uiPrefsViewSelection->box(FL_EMBOSSED_BOX);
            uiPrefsViewSelection->labelsize(11);
            uiPrefsViewSelection->callback((Fl_Callback*)cb_uiPrefsViewSelection, (void*)(this));
            uiPrefsViewSelection->align(Fl_Align(FL_ALIGN_LEFT));
          } // Fl_Button* uiPrefsViewSelection
          { uiPrefsViewHud = new Fl_Button(523, 280, 25, 25, "HUD");
            uiPrefsViewHud->tooltip("Selects the color of HUD overlays.");
            uiPrefsViewHud->box(FL_EMBOSSED_BOX);
            uiPrefsViewHud->callback((Fl_Callback*)cb_uiPrefsViewHud, (void*)(this));
            uiPrefsViewHud->align(Fl_Align(FL_ALIGN_LEFT));
          } // Fl_Button* uiPrefsViewHud
          o->end();
        } // Fl_Group* o
        o->end();
      } // Fl_Group* o
      { Fl_Group* o = new Fl_Group(231, 46, 425, 361, "File Requester");
        o->box(FL_EMBOSSED_BOX);
        o->align(Fl_Align(FL_ALIGN_TOP_LEFT));
        o->hide();
        { uiPrefsFileReqFolder = new Fl_Check_Button(291, 81, 25, 25, "Single Click to Travel Drawers");
          uiPrefsFileReqFolder->box(FL_UP_BOX);
          uiPrefsFileReqFolder->down_box(FL_DOWN_BOX);
        } // Fl_Check_Button* uiPrefsFileReqFolder
        { uiPrefsNativeFileChooser = new Fl_Check_Button(292, 110, 25, 25, "Use Native File Chooser on Windows");
          uiPrefsNativeFileChooser->tooltip("On Windows, if selected, the native file chooser will be used.  If unselected\
, mrViewer\'s standard file chooser will be used.");
          uiPrefsNativeFileChooser->box(FL_UP_BOX);
          uiPrefsNativeFileChooser->down_box(FL_DOWN_BOX);
        } // Fl_Check_Button* uiPrefsNativeFileChooser
        o->end();
      } // Fl_Group* o
      { Playback = new Fl_Group(233, 46, 425, 360, "Playback");
        Playback->box(FL_EMBOSSED_BOX);
        Playback->align(Fl_Align(FL_ALIGN_TOP_LEFT));
        Playback->hide();
        { Fl_Group* o = new Fl_Group(283, 115, 285, 136, "Defaults");
          o->box(FL_ROUNDED_BOX);
          o->align(Fl_Align(FL_ALIGN_TOP_LEFT));
          { Fl_Group* o = new Fl_Group(393, 164, 152, 26);
            { uiPrefsFPS = new Fl_Value_Input(393, 165, 75, 25, "Speed");
              uiPrefsFPS->color((Fl_Color)-1733777408);
              uiPrefsFPS->selection_color(FL_FOREGROUND_COLOR);
              uiPrefsFPS->minimum(0.001);
              uiPrefsFPS->maximum(120);
              uiPrefsFPS->step(0.01);
              uiPrefsFPS->value(24);
            } // Fl_Value_Input* uiPrefsFPS
            o->end();
          } // Fl_Group* o
          { uiPrefsLoopMode = new Fl_Choice(393, 195, 90, 25, "Looping Mode");
            uiPrefsLoopMode->tooltip("Select default looping mode in timeline.");
            uiPrefsLoopMode->box(FL_THIN_DOWN_BOX);
            uiPrefsLoopMode->down_box(FL_BORDER_BOX);
            uiPrefsLoopMode->menu(menu_uiPrefsLoopMode);
          } // Fl_Choice* uiPrefsLoopMode
          { uiPrefsAutoPlayback = new Fl_Check_Button(450, 135, 20, 25, "Auto Playback");
            uiPrefsAutoPlayback->tooltip("Start Playback when opening files.");
            uiPrefsAutoPlayback->box(FL_UP_BOX);
            uiPrefsAutoPlayback->down_box(FL_DOWN_BOX);
            uiPrefsAutoPlayback->align(Fl_Align(FL_ALIGN_LEFT));
          } // Fl_Check_Button* uiPrefsAutoPlayback
          o->end();
        } // Fl_Group* o
        Playback->end();
      } // Fl_Group* Playback
      { Fl_Group* o = new Fl_Group(231, 46, 425, 364, "Caches");
        o->box(FL_EMBOSSED_BOX);
        o->align(Fl_Align(FL_ALIGN_TOP_LEFT));
        o->hide();
        { uiPrefsCacheActive = new Fl_Check_Button(270, 76, 20, 25, "Cache Active");
          uiPrefsCacheActive->tooltip("Image sequences will be cached in memory.  If this setting is off, images wil\
l be loaded on demand but fluid playback may not be possible.");
          uiPrefsCacheActive->box(FL_UP_BOX);
          uiPrefsCacheActive->down_box(FL_DOWN_BOX);
          uiPrefsCacheActive->align(Fl_Align(FL_ALIGN_RIGHT));
        } // Fl_Check_Button* uiPrefsCacheActive
        { uiPrefs8BitCaches = new Fl_Check_Button(270, 115, 20, 25, "8 bit Caches");
          uiPrefs8BitCaches->tooltip("Image sequences will be cached as 8-bit pictures, instead of being cached as \
the original depth of the sequence.\nThis setting thus allows caching more pic\
tures in memory for float and half pictures.");
          uiPrefs8BitCaches->box(FL_UP_BOX);
          uiPrefs8BitCaches->down_box(FL_DOWN_BOX);
          uiPrefs8BitCaches->align(Fl_Align(FL_ALIGN_RIGHT));
        } // Fl_Check_Button* uiPrefs8BitCaches
        { uiPrefsPreloadCache = new Fl_Check_Button(470, 75, 20, 25, "Preload Cache");
          uiPrefsPreloadCache->tooltip("When this option is on and a sequence is loaded, the frames of the cache will\
 begin loading in the background.  Note however, that this may make the GUI le\
ss responsive.");
          uiPrefsPreloadCache->box(FL_UP_BOX);
          uiPrefsPreloadCache->down_box(FL_DOWN_BOX);
          uiPrefsPreloadCache->align(Fl_Align(FL_ALIGN_RIGHT));
        } // Fl_Check_Button* uiPrefsPreloadCache
        { uiPrefsCacheScale = new Fl_Choice(305, 160, 120, 25, "Scale");
          uiPrefsCacheScale->tooltip("Scale of images stored.  Smaller scale allows more images to be stored at the\
 expense of pixelization.");
          uiPrefsCacheScale->box(FL_THIN_DOWN_BOX);
          uiPrefsCacheScale->down_box(FL_BORDER_BOX);
          uiPrefsCacheScale->menu(menu_uiPrefsCacheScale);
        } // Fl_Choice* uiPrefsCacheScale
        { Fl_Group* o = new Fl_Group(270, 235, 336, 45, "Cache Size");
          o->box(FL_ROUNDED_BOX);
          { Fl_Value_Slider* o = uiPrefsCacheSize = new Fl_Value_Slider(284, 246, 246, 27);
            uiPrefsCacheSize->tooltip("Size in frames of the video and audio cache.");
            uiPrefsCacheSize->minimum(30);
            uiPrefsCacheSize->maximum(200);
            uiPrefsCacheSize->step(1);
            uiPrefsCacheSize->value(60);
            uiPrefsCacheSize->align(Fl_Align(FL_ALIGN_TOP));
            o->activate(false);
          } // Fl_Value_Slider* uiPrefsCacheSize
          { uiPrefsCacheFPS = new Fl_Light_Button(530, 243, 60, 30, "FPS");
            uiPrefsCacheFPS->tooltip("When selected, cache is set to twice the frames per second of the movie.");
            uiPrefsCacheFPS->callback((Fl_Callback*)cb_uiPrefsCacheFPS, (void*)(uiPrefsCacheSize));
          } // Fl_Light_Button* uiPrefsCacheFPS
          o->end();
        } // Fl_Group* o
        o->end();
      } // Fl_Group* o
      { Fl_Group* o = new Fl_Group(231, 49, 425, 358, "3D Luts");
        o->box(FL_EMBOSSED_BOX);
        o->align(Fl_Align(FL_ALIGN_TOP_LEFT));
        o->hide();
        { Fl_Group* o = new Fl_Group(271, 94, 343, 105, "Algorithm");
          o->tooltip("mrViewer supports either ICC profiles or a CTL script for your output device \
transform (ODT) and for your rendering transform of your images (RT).  These s\
ettings prioritizes choosing one over the other.");
          o->box(FL_ROUNDED_BOX);
          { ODT_algorithm = new Fl_Choice(366, 112, 195, 25, "ODT");
            ODT_algorithm->tooltip("mrViewer supports either ICC profiles or a CTL script for your output device \
transform (ODT).  This setting prioritizes choosing one over the other.\nWhen \
mixing a CTL ODT script with an ICC profile in an image as rendering transform\
 (RT), it is necessary that the CTL ODT reads data in XYZ_OCES space (ICC v4 r\
elative colorimetric).  Also, note that ICC uses D50 white points while HDTV a\
nd CTL use D65 white points.\nIf unsure what this means, keep your display and\
 images setting always using the same algorithm (CTL or ICC).");
            ODT_algorithm->box(FL_THIN_DOWN_BOX);
            ODT_algorithm->down_box(FL_BORDER_BOX);
            ODT_algorithm->callback((Fl_Callback*)cb_ODT_algorithm, (void*)(this));
            ODT_algorithm->menu(menu_ODT_algorithm);
          } // Fl_Choice* ODT_algorithm
          { RT_algorithm = new Fl_Choice(366, 164, 195, 25, "RT");
            RT_algorithm->tooltip("mrViewer supports either ICC profiles or a CTL script for the render transfor\
m (RT) of your images.  This setting prioritizes choosing one over the other. \
\nWhen mixing a CTL RT script with an ICC profile for your output device trans\
form (ODT) like your monitor profile, it is necessary that the CTL RT script p\
asses data in XYZ_OCES space (ICC v4 relative colorimetric).\nIf unsure what t\
his means, keep your display and images setting always using the same algorith\
m (CTL or ICC).");
            RT_algorithm->box(FL_THIN_DOWN_BOX);
            RT_algorithm->down_box(FL_BORDER_BOX);
            RT_algorithm->callback((Fl_Callback*)cb_RT_algorithm, (void*)(this));
            RT_algorithm->menu(menu_RT_algorithm);
          } // Fl_Choice* RT_algorithm
          o->end();
        } // Fl_Group* o
        { Fl_Group* o = new Fl_Group(274, 289, 340, 75, "Quality");
          o->tooltip("mrViewer supports CTL scripts and ICC profiles baked into 3D Luts.  These set\
tings control the quality of the 3D Lut.");
          o->box(FL_ROUNDED_BOX);
          { uiLUT_quality = new Fl_Choice(394, 314, 170, 25, "Resolution");
            uiLUT_quality->tooltip("With modern graphics cards, mrViewer emulates color transforms by baking them\
 into a 3D Lut.  This setting controls how accurate the 3D lut is.  The bigger\
 the lut, the longer it takes to calculate but the more accurate it is.\nNote \
that large 3D Luts can use quite a lot of memory.  \n\nSize     Memory    Max.\
 Error\n32        1/3 Mb     12.5%\n64          3 Mb      1.6%\n128       24 M\
b       0.7%\n\nIt is recommended this setting is left at 64x64x64.\n\nThe \"N\
o Baking\" setting performs the color correction on the image directly instead\
 of in a 3D lut.  It is a non real-time operation whose speed depends on the i\
mage size and can only be done when not playing a movie.");
            uiLUT_quality->box(FL_THIN_DOWN_BOX);
            uiLUT_quality->down_box(FL_BORDER_BOX);
            uiLUT_quality->callback((Fl_Callback*)cb_uiLUT_quality, (void*)(this));
            uiLUT_quality->menu(menu_uiLUT_quality);
          } // Fl_Choice* uiLUT_quality
          o->end();
        } // Fl_Group* o
        { Fl_Group* o = new Fl_Group(274, 224, 340, 45, "Rendering Intent");
          o->box(FL_ROUNDED_BOX);
          { uiICC_intent = new Fl_Choice(394, 234, 170, 25, "ICC");
            uiICC_intent->tooltip("When using luts with ICC profiles, this setting allows you to select the ICC \
rendering intent.   Rendering intents are mostly used for printing to film or \
paper to emulate or proof the output of the output device (ODT), particularly \
when it does not have the same gamut (color/white range) as the linear RGB/XYZ\
 space.");
            uiICC_intent->box(FL_THIN_DOWN_BOX);
            uiICC_intent->down_box(FL_BORDER_BOX);
            uiICC_intent->callback((Fl_Callback*)cb_uiICC_intent, (void*)(this));
            uiICC_intent->menu(menu_uiICC_intent);
          } // Fl_Choice* uiICC_intent
          o->end();
        } // Fl_Group* o
        o->end();
      } // Fl_Group* o
      { Fl_Group* o = new Fl_Group(233, 46, 425, 367, "CTL Paths");
        o->box(FL_EMBOSSED_BOX);
        o->align(Fl_Align(FL_ALIGN_TOP_LEFT));
        o->hide();
        { uiPrefsCTLModulePath = new Fl_Browser(246, 78, 380, 110, "CTL_MODULE_PATH");
        } // Fl_Browser* uiPrefsCTLModulePath
        { uiPrefsCTLScripts = new Fl_Browser(246, 223, 380, 190, "CTL scripts");
        } // Fl_Browser* uiPrefsCTLScripts
        o->end();
      } // Fl_Group* o
      { Fl_Group* o = new Fl_Group(233, 46, 425, 367, "Default Output Device Transform (ODT)");
        o->box(FL_EMBOSSED_BOX);
        o->align(Fl_Align(FL_ALIGN_TOP_LEFT));
        o->hide();
        { Fl_Group* o = new Fl_Group(246, 68, 370, 345, "Display");
          o->box(FL_ROUNDED_BOX);
          { uiODT_CTL = new Fl_Group(350, 78, 255, 265);
            { Fl_Group* o = new Fl_Group(350, 78, 255, 35);
              { uiODT_CTL_transform = new Fl_Input(365, 83, 185, 25, "Transform");
                uiODT_CTL_transform->tooltip("The name of the CTL display transform\n(Environment variable: MRV_ODT_CTL_TRA\
NSFORM)");
                uiODT_CTL_transform->box(FL_THIN_DOWN_BOX);
                uiODT_CTL_transform->labelsize(11);
                uiODT_CTL_transform->callback((Fl_Callback*)cb_uiODT_CTL_transform, (void*)(this));
              } // Fl_Input* uiODT_CTL_transform
              { Fl_Button* o = new Fl_Button(550, 83, 55, 25, "Pick");
                o->callback((Fl_Callback*)cb_Pick);
              } // Fl_Button* o
              o->end();
            } // Fl_Group* o
            { Fl_Group* o = new Fl_Group(355, 113, 250, 155, "Chromaticities (CIE)");
              o->tooltip("The CIE x,y coordinates of the primaries and white point of the display\n(lik\
e Rec. ITU-R BT.709-3)\n\n(Environment variable: MRV_ODT_CTL_CHROMATICITIES)");
              o->box(FL_ENGRAVED_BOX);
              o->align(Fl_Align(132));
              { Fl_Group* o = new Fl_Group(400, 136, 190, 35, "Red");
                o->labelsize(11);
                o->align(Fl_Align(FL_ALIGN_LEFT));
                { uiODT_CTL_chromaticities_red_x = new Fl_Value_Input(410, 146, 85, 25);
                uiODT_CTL_chromaticities_red_x->tooltip("The Red CIE X coordinate of the display");
                uiODT_CTL_chromaticities_red_x->step(0.0001);
                uiODT_CTL_chromaticities_red_x->value(0.64);
                uiODT_CTL_chromaticities_red_x->callback((Fl_Callback*)cb_uiODT_CTL_chromaticities_red_x);
                } // Fl_Value_Input* uiODT_CTL_chromaticities_red_x
                { uiODT_CTL_chromaticities_red_y = new Fl_Value_Input(505, 146, 85, 25);
                uiODT_CTL_chromaticities_red_y->tooltip("The Red CIE Y coordinate of the display");
                uiODT_CTL_chromaticities_red_y->step(0.0001);
                uiODT_CTL_chromaticities_red_y->value(0.33);
                uiODT_CTL_chromaticities_red_y->callback((Fl_Callback*)cb_uiODT_CTL_chromaticities_red_y);
                } // Fl_Value_Input* uiODT_CTL_chromaticities_red_y
                o->end();
              } // Fl_Group* o
              { Fl_Group* o = new Fl_Group(400, 166, 190, 35, "Green");
                o->labelsize(11);
                o->align(Fl_Align(FL_ALIGN_LEFT));
                { uiODT_CTL_chromaticities_green_x = new Fl_Value_Input(410, 176, 85, 25);
                uiODT_CTL_chromaticities_green_x->tooltip("The Green CIE X coordinate of the display");
                uiODT_CTL_chromaticities_green_x->step(0.0001);
                uiODT_CTL_chromaticities_green_x->value(0.3);
                uiODT_CTL_chromaticities_green_x->callback((Fl_Callback*)cb_uiODT_CTL_chromaticities_green_x);
                } // Fl_Value_Input* uiODT_CTL_chromaticities_green_x
                { uiODT_CTL_chromaticities_green_y = new Fl_Value_Input(505, 176, 85, 25);
                uiODT_CTL_chromaticities_green_y->tooltip("The Green CIE Y coordinate of the display");
                uiODT_CTL_chromaticities_green_y->step(0.0001);
                uiODT_CTL_chromaticities_green_y->value(0.6);
                uiODT_CTL_chromaticities_green_y->callback((Fl_Callback*)cb_uiODT_CTL_chromaticities_green_y);
                } // Fl_Value_Input* uiODT_CTL_chromaticities_green_y
                o->end();
              } // Fl_Group* o
              { Fl_Group* o = new Fl_Group(400, 196, 190, 35, "Blue");
                o->labelsize(11);
                o->align(Fl_Align(FL_ALIGN_LEFT));
                { uiODT_CTL_chromaticities_blue_x = new Fl_Value_Input(410, 206, 85, 25);
                uiODT_CTL_chromaticities_blue_x->tooltip("The Blue CIE X coordinate of the display");
                uiODT_CTL_chromaticities_blue_x->step(0.0001);
                uiODT_CTL_chromaticities_blue_x->value(0.15);
                uiODT_CTL_chromaticities_blue_x->callback((Fl_Callback*)cb_uiODT_CTL_chromaticities_blue_x, (void*)(this));
                } // Fl_Value_Input* uiODT_CTL_chromaticities_blue_x
                { uiODT_CTL_chromaticities_blue_y = new Fl_Value_Input(505, 206, 85, 25);
                uiODT_CTL_chromaticities_blue_y->tooltip("The Blue CIE Y coordinate of the display");
                uiODT_CTL_chromaticities_blue_y->step(0.0001);
                uiODT_CTL_chromaticities_blue_y->value(0.06);
                uiODT_CTL_chromaticities_blue_y->callback((Fl_Callback*)cb_uiODT_CTL_chromaticities_blue_y, (void*)(this));
                } // Fl_Value_Input* uiODT_CTL_chromaticities_blue_y
                o->end();
              } // Fl_Group* o
              { Fl_Group* o = new Fl_Group(400, 226, 190, 35, "White");
                o->labelsize(11);
                o->align(Fl_Align(FL_ALIGN_LEFT));
                { uiODT_CTL_chromaticities_white_x = new Fl_Value_Input(410, 236, 85, 25);
                uiODT_CTL_chromaticities_white_x->tooltip("The White CIE X coordinate of the display");
                uiODT_CTL_chromaticities_white_x->step(0.0001);
                uiODT_CTL_chromaticities_white_x->value(0.3127);
                uiODT_CTL_chromaticities_white_x->callback((Fl_Callback*)cb_uiODT_CTL_chromaticities_white_x, (void*)(this));
                } // Fl_Value_Input* uiODT_CTL_chromaticities_white_x
                { uiODT_CTL_chromaticities_white_y = new Fl_Value_Input(505, 236, 85, 25);
                uiODT_CTL_chromaticities_white_y->tooltip("The White CIE Y coordinate of the display");
                uiODT_CTL_chromaticities_white_y->step(0.0001);
                uiODT_CTL_chromaticities_white_y->value(0.329);
                uiODT_CTL_chromaticities_white_y->callback((Fl_Callback*)cb_uiODT_CTL_chromaticities_white_y, (void*)(this));
                } // Fl_Value_Input* uiODT_CTL_chromaticities_white_y
                o->end();
              } // Fl_Group* o
              o->end();
            } // Fl_Group* o
            { Fl_Group* o = new Fl_Group(465, 278, 130, 35, "White Luminance");
              o->labelsize(11);
              o->align(Fl_Align(132));
              { uiODT_CTL_white_luminance = new Fl_Value_Input(475, 283, 90, 25, "cd/m2");
                uiODT_CTL_white_luminance->tooltip("The luminance, in cd/m2, of the display.\n\n(Environment variable:\nCTL_DISPL\
AY_WHITE_LUMINANCE)");
                uiODT_CTL_white_luminance->maximum(500);
                uiODT_CTL_white_luminance->step(0.1);
                uiODT_CTL_white_luminance->value(120);
                uiODT_CTL_white_luminance->callback((Fl_Callback*)cb_uiODT_CTL_white_luminance, (void*)(this));
                uiODT_CTL_white_luminance->align(Fl_Align(136));
              } // Fl_Value_Input* uiODT_CTL_white_luminance
              o->end();
            } // Fl_Group* o
            { Fl_Group* o = new Fl_Group(475, 308, 120, 35, "Surround Luminance");
              o->tooltip("(Environment variable:\nCTL_DISPLAY_WHITE_LUMINANCE)");
              o->labelsize(11);
              o->align(Fl_Align(132));
              { uiODT_CTL_surround_luminance = new Fl_Value_Input(475, 318, 90, 25, "cd/m2");
                uiODT_CTL_surround_luminance->tooltip("The luminance, in cd/m2, of the background that surrounds the display.\n\n(En\
vironment variable:\nMRV_ODT_CTL_SURROUND_LUMINANCE)");
                uiODT_CTL_surround_luminance->maximum(500);
                uiODT_CTL_surround_luminance->step(0.1);
                uiODT_CTL_surround_luminance->value(12);
                uiODT_CTL_surround_luminance->callback((Fl_Callback*)cb_uiODT_CTL_surround_luminance, (void*)(this));
                uiODT_CTL_surround_luminance->align(Fl_Align(136));
              } // Fl_Value_Input* uiODT_CTL_surround_luminance
              o->end();
            } // Fl_Group* o
            uiODT_CTL->end();
          } // Fl_Group* uiODT_CTL
          { uiODT_ICC = new Fl_Group(281, 353, 312, 45);
            { uiODT_ICC_profile = new Fl_Input(336, 368, 190, 25, "ICC profile");
              uiODT_ICC_profile->tooltip("The name of the default ICC profile for your ODT (monitor)\n(Environment vari\
able: MRV_ODT_ICC_PROFILE)");
              uiODT_ICC_profile->box(FL_THIN_DOWN_BOX);
              uiODT_ICC_profile->labelsize(11);
              uiODT_ICC_profile->callback((Fl_Callback*)cb_uiODT_ICC_profile, (void*)(this));
              uiODT_ICC_profile->align(Fl_Align(132));
            } // Fl_Input* uiODT_ICC_profile
            { Fl_Button* o = new Fl_Button(526, 368, 55, 25, "Load");
              o->callback((Fl_Callback*)cb_Load, (void*)(this));
            } // Fl_Button* o
            uiODT_ICC->end();
          } // Fl_Group* uiODT_ICC
          o->end();
        } // Fl_Group* o
        o->end();
      } // Fl_Group* o
      { Fl_Group* o = new Fl_Group(233, 46, 425, 367, "Default Rendering Transform (RT)");
        o->box(FL_EMBOSSED_BOX);
        o->align(Fl_Align(FL_ALIGN_TOP_LEFT));
        o->hide();
        { uiRT_CTL = new Fl_Group(248, 70, 375, 155, "Render Transforms");
          uiRT_CTL->box(FL_ROUNDED_BOX);
          { Fl_Group* o = new Fl_Group(348, 85, 255, 30);
            { uiCTL_8bits_load_transform = new Fl_Input(348, 85, 190, 25, "8-bits");
              uiCTL_8bits_load_transform->tooltip("The name of the CTL default image transform for 8 bit images (jpg, bmp, etc)\
\n(Environment variable: MRV_CTL_RT_8bits)");
              uiCTL_8bits_load_transform->box(FL_THIN_DOWN_BOX);
              uiCTL_8bits_load_transform->labelsize(11);
              uiCTL_8bits_load_transform->callback((Fl_Callback*)cb_uiCTL_8bits_load_transform, (void*)(this));
              uiCTL_8bits_load_transform->align(Fl_Align(132));
            } // Fl_Input* uiCTL_8bits_load_transform
            { Fl_Button* o = new Fl_Button(538, 85, 55, 25, "Pick");
              o->callback((Fl_Callback*)cb_Pick1, (void*)(this));
            } // Fl_Button* o
            o->end();
          } // Fl_Group* o
          { Fl_Group* o = new Fl_Group(348, 115, 255, 30);
            { uiCTL_16bits_load_transform = new Fl_Input(348, 115, 190, 25, "16-bits");
              uiCTL_16bits_load_transform->tooltip("The name of the CTL default image transform for 16-bit images (cin, tiff, etc\
)\n(Environment variable: MRV_CTL_RT_16bits)");
              uiCTL_16bits_load_transform->box(FL_THIN_DOWN_BOX);
              uiCTL_16bits_load_transform->labelsize(11);
              uiCTL_16bits_load_transform->callback((Fl_Callback*)cb_uiCTL_16bits_load_transform, (void*)(this));
              uiCTL_16bits_load_transform->align(Fl_Align(132));
            } // Fl_Input* uiCTL_16bits_load_transform
            { Fl_Button* o = new Fl_Button(538, 115, 55, 25, "Pick");
              o->callback((Fl_Callback*)cb_Pick2, (void*)(this));
            } // Fl_Button* o
            o->end();
          } // Fl_Group* o
          { Fl_Group* o = new Fl_Group(348, 145, 255, 30);
            { uiCTL_32bits_load_transform = new Fl_Input(348, 145, 190, 25, "32-bits");
              uiCTL_32bits_load_transform->tooltip("The name of the CTL default image transform for 32-bit int images (openexr in\
tegers, etc)\n(Environment variable: MRV_CTL_RT_32bits)");
              uiCTL_32bits_load_transform->box(FL_THIN_DOWN_BOX);
              uiCTL_32bits_load_transform->labelsize(11);
              uiCTL_32bits_load_transform->callback((Fl_Callback*)cb_uiCTL_32bits_load_transform, (void*)(this));
              uiCTL_32bits_load_transform->align(Fl_Align(132));
            } // Fl_Input* uiCTL_32bits_load_transform
            { Fl_Button* o = new Fl_Button(538, 145, 55, 25, "Pick");
              o->callback((Fl_Callback*)cb_Pick3, (void*)(this));
            } // Fl_Button* o
            o->end();
          } // Fl_Group* o
          { Fl_Group* o = new Fl_Group(348, 175, 255, 30);
            { uiCTL_float_load_transform = new Fl_Input(348, 175, 190, 25, "float");
              uiCTL_float_load_transform->tooltip("The name of the CTL default image transform for half and float images (OpenEX\
R, dpx, etc)\n(Environment variable: MRV_CTL_RT_float)");
              uiCTL_float_load_transform->box(FL_THIN_DOWN_BOX);
              uiCTL_float_load_transform->labelsize(11);
              uiCTL_float_load_transform->callback((Fl_Callback*)cb_uiCTL_float_load_transform, (void*)(this));
              uiCTL_float_load_transform->align(Fl_Align(132));
            } // Fl_Input* uiCTL_float_load_transform
            { Fl_Button* o = new Fl_Button(538, 175, 55, 25, "Pick");
              o->callback((Fl_Callback*)cb_Pick4, (void*)(this));
            } // Fl_Button* o
            o->end();
          } // Fl_Group* o
          uiRT_CTL->end();
        } // Fl_Group* uiRT_CTL
        { uiRT_ICC = new Fl_Group(248, 250, 375, 155, "ICC Profiles");
          uiRT_ICC->box(FL_ROUNDED_BOX);
          { Fl_Group* o = new Fl_Group(348, 265, 255, 30);
            { uiICC_8bits_profile = new Fl_Input(348, 265, 190, 25, "8-bits");
              uiICC_8bits_profile->tooltip("The name of the default ICC profile for 8 bit images (jpg, bmp, etc)\n(Enviro\
nment variable: MRV_ICC_RT_8bits)");
              uiICC_8bits_profile->box(FL_THIN_DOWN_BOX);
              uiICC_8bits_profile->labelsize(11);
              uiICC_8bits_profile->callback((Fl_Callback*)cb_uiICC_8bits_profile, (void*)(this));
              uiICC_8bits_profile->align(Fl_Align(132));
            } // Fl_Input* uiICC_8bits_profile
            { Fl_Button* o = new Fl_Button(538, 265, 55, 25, "Load");
              o->callback((Fl_Callback*)cb_Load1, (void*)(this));
            } // Fl_Button* o
            o->end();
          } // Fl_Group* o
          { Fl_Group* o = new Fl_Group(348, 295, 255, 30);
            { uiICC_16bits_profile = new Fl_Input(348, 295, 190, 25, "16-bits");
              uiICC_16bits_profile->tooltip("The name of the default ICC profile for 16-bit images (cin, tiff, etc)\n(Envi\
ronment variable: MRV_ICC_RT_16bits)");
              uiICC_16bits_profile->box(FL_THIN_DOWN_BOX);
              uiICC_16bits_profile->labelsize(11);
              uiICC_16bits_profile->callback((Fl_Callback*)cb_uiICC_16bits_profile, (void*)(this));
              uiICC_16bits_profile->align(Fl_Align(132));
            } // Fl_Input* uiICC_16bits_profile
            { Fl_Button* o = new Fl_Button(538, 295, 55, 25, "Load");
              o->callback((Fl_Callback*)cb_Load2, (void*)(this));
            } // Fl_Button* o
            o->end();
          } // Fl_Group* o
          { Fl_Group* o = new Fl_Group(348, 325, 255, 30);
            { uiICC_32bits_profile = new Fl_Input(348, 325, 190, 25, "32-bits");
              uiICC_32bits_profile->tooltip("The name of the default ICC profile for 32-bit int images (openexr integers, \
etc)\n(Environment variable: MRV_ICC_RT_32bits)");
              uiICC_32bits_profile->box(FL_THIN_DOWN_BOX);
              uiICC_32bits_profile->labelsize(11);
              uiICC_32bits_profile->callback((Fl_Callback*)cb_uiICC_32bits_profile, (void*)(this));
              uiICC_32bits_profile->align(Fl_Align(132));
            } // Fl_Input* uiICC_32bits_profile
            { Fl_Button* o = new Fl_Button(538, 325, 55, 25, "Load");
              o->callback((Fl_Callback*)cb_Load3, (void*)(this));
            } // Fl_Button* o
            o->end();
          } // Fl_Group* o
          { Fl_Group* o = new Fl_Group(348, 355, 255, 30);
            { uiICC_float_profile = new Fl_Input(348, 355, 190, 25, "float");
              uiICC_float_profile->tooltip("The name of the default ICC profile for half and float images (OpenEXR, dpx, \
etc)\n(Environment variable: MRV_ICC_RT_float)");
              uiICC_float_profile->box(FL_THIN_DOWN_BOX);
              uiICC_float_profile->labelsize(11);
              uiICC_float_profile->callback((Fl_Callback*)cb_uiICC_float_profile, (void*)(this));
              uiICC_float_profile->align(Fl_Align(132));
            } // Fl_Input* uiICC_float_profile
            { Fl_Button* o = new Fl_Button(538, 355, 55, 25, "Load");
              o->callback((Fl_Callback*)cb_Load4, (void*)(this));
            } // Fl_Button* o
            o->end();
          } // Fl_Group* o
          uiRT_ICC->end();
        } // Fl_Group* uiRT_ICC
        o->end();
      } // Fl_Group* o
      { Fl_Group* o = new Fl_Group(233, 46, 425, 360, "Loading");
        o->box(FL_EMBOSSED_BOX);
        o->align(Fl_Align(FL_ALIGN_TOP_LEFT));
        o->hide();
        { Fl_Group* o = new Fl_Group(246, 91, 400, 104);
          o->box(FL_ROUNDED_BOX);
          { uiPrefsLoadSequence = new Fl_Check_Button(266, 135, 25, 25, " Load Sequence on Drag&&Drop");
            uiPrefsLoadSequence->tooltip("When dragging and dropping a frame from a sequence, make mrViewerr load the f\
ull sequence.   Otherwise it loads the frame only.");
            uiPrefsLoadSequence->box(FL_UP_BOX);
            uiPrefsLoadSequence->down_box(FL_DOWN_BOX);
            uiPrefsLoadSequence->value(1);
          } // Fl_Check_Button* uiPrefsLoadSequence
          o->end();
        } // Fl_Group* o
        o->end();
      } // Fl_Group* o
      { Fl_Group* o = new Fl_Group(233, 46, 425, 361, "Video");
        o->box(FL_EMBOSSED_BOX);
        o->align(Fl_Align(FL_ALIGN_TOP_LEFT));
        o->hide();
        { VideoDriver = new Fl_Choice(311, 83, 290, 25, "Driver");
          VideoDriver->box(FL_THIN_DOWN_BOX);
          VideoDriver->down_box(FL_BORDER_BOX);
          VideoDriver->menu(menu_VideoDriver);
        } // Fl_Choice* VideoDriver
        { Fl_Group* o = new Fl_Group(281, 143, 318, 65, "Stereo");
          o->box(FL_ROUNDED_BOX);
          { uiPrefsStereoRightEyeInverted = new Fl_Light_Button(338, 158, 212, 35, "Right Eye Inverted");
            uiPrefsStereoRightEyeInverted->tooltip("This option controls stereo viewing of interlaced and checkerboard.");
          } // Fl_Light_Button* uiPrefsStereoRightEyeInverted
          o->end();
        } // Fl_Group* o
        { Fl_Group* o = new Fl_Group(276, 318, 325, 65);
          o->box(FL_ROUNDED_BOX);
          { uiPrefsBlendMode = new Fl_Choice(408, 343, 167, 25, "Blend Mode");
            uiPrefsBlendMode->tooltip("OpenGL blend compositing mode.\nTraditional:\nSC x SA + DC x ( 1 - SA)\nPremu\
lt:\nSC + DC x ( 1 - SA )\nwhere SC is source color, SA is source alpha, and D\
C is destination color.");
            uiPrefsBlendMode->box(FL_THIN_DOWN_BOX);
            uiPrefsBlendMode->down_box(FL_BORDER_BOX);
            uiPrefsBlendMode->user_data((void*)(uiMain));
            uiPrefsBlendMode->menu(menu_uiPrefsBlendMode);
          } // Fl_Choice* uiPrefsBlendMode
          o->end();
        } // Fl_Group* o
        o->end();
      } // Fl_Group* o
      { Fl_Group* o = new Fl_Group(231, 46, 427, 367, "Audio");
        o->box(FL_EMBOSSED_BOX);
        o->align(Fl_Align(FL_ALIGN_TOP_LEFT));
        o->hide();
        { AudioDriver = new Fl_Choice(294, 68, 316, 25, "Driver");
          AudioDriver->box(FL_THIN_DOWN_BOX);
          AudioDriver->down_box(FL_BORDER_BOX);
        } // Fl_Choice* AudioDriver
        { Fl_Browser* o = uiPrefsAudioDevice = new Fl_Browser(256, 116, 379, 107, "Devices");
          uiPrefsAudioDevice->type(3);
          uiPrefsAudioDevice->box(FL_NO_BOX);
          uiPrefsAudioDevice->color(FL_BACKGROUND2_COLOR);
          uiPrefsAudioDevice->selection_color(FL_SELECTION_COLOR);
          uiPrefsAudioDevice->labeltype(FL_NORMAL_LABEL);
          uiPrefsAudioDevice->labelfont(0);
          uiPrefsAudioDevice->labelsize(14);
          uiPrefsAudioDevice->labelcolor(FL_FOREGROUND_COLOR);
          uiPrefsAudioDevice->align(Fl_Align(FL_ALIGN_BOTTOM));
          uiPrefsAudioDevice->when(FL_WHEN_RELEASE_ALWAYS);
          //
// Initialize an audio engine to get devices
//
mrv::AudioEngine* engine = mrv::AudioEngine::factory();
delete engine;

const mrv::AudioEngine::DeviceList& devices = mrv::AudioEngine::devices();
mrv::AudioEngine::DeviceList::const_iterator i = devices.begin();
mrv::AudioEngine::DeviceList::const_iterator e = devices.end();
for ( ; i != e; ++i )
   {
      o->add( (*i).description.c_str() );
   }
        } // Fl_Browser* uiPrefsAudioDevice
        { Fl_Group* o = new Fl_Group(295, 235, 300, 60);
          o->box(FL_ROUND_DOWN_BOX);
          { uiPrefsAudioVolume = new Fl_Slider(374, 255, 161, 25, "Default Volume");
            uiPrefsAudioVolume->tooltip("Default audio at opening mrViewer.");
            uiPrefsAudioVolume->step(0.01);
            uiPrefsAudioVolume->value(1);
            uiPrefsAudioVolume->align(Fl_Align(FL_ALIGN_TOP));
          } // Fl_Slider* uiPrefsAudioVolume
          { uiPrefsAudioMute = new Fl_Button(335, 255, 40, 25, "Mute");
            uiPrefsAudioMute->callback((Fl_Callback*)cb_uiPrefsAudioMute, (void*)(uiPrefsAudioVolume));
          } // Fl_Button* uiPrefsAudioMute
          o->end();
        } // Fl_Group* o
        o->end();
      } // Fl_Group* o
      { Fl_Group* o = new Fl_Group(230, 48, 427, 367, "Images");
        o->tooltip("Options controlling the OpenEXR reader/writer");
        o->box(FL_EMBOSSED_BOX);
        o->align(Fl_Align(FL_ALIGN_TOP_LEFT));
        { Fl_Group* o = new Fl_Group(284, 126, 330, 130, "Saving");
          o->box(FL_ROUNDED_BOX);
          o->labelsize(15);
          { uiPrefsACESClipMetadata = new Fl_Light_Button(344, 146, 210, 30, "ACES Clip Metadata");
            uiPrefsACESClipMetadata->tooltip("Whether to save ACES clip metadata in a sidecar.");
          } // Fl_Light_Button* uiPrefsACESClipMetadata
          { uiPrefsAllLayers = new Fl_Light_Button(344, 196, 210, 30, "All Layers");
            uiPrefsAllLayers->tooltip("Whether to save all layers in image file if there are several.");
          } // Fl_Light_Button* uiPrefsAllLayers
          o->end();
        } // Fl_Group* o
        o->end();
      } // Fl_Group* o
      { Fl_Group* o = new Fl_Group(231, 47, 427, 367, "OpenEXR");
        o->tooltip("Options controlling the OpenEXR reader/writer");
        o->box(FL_EMBOSSED_BOX);
        o->align(Fl_Align(FL_ALIGN_TOP_LEFT));
        o->hide();
        { Fl_Group* o = new Fl_Group(275, 80, 325, 130, "Loading");
          o->box(FL_ROUNDED_BOX);
          o->labelsize(15);
          { uiPrefsOpenEXRThreadCount = new Fl_Value_Input(430, 102, 51, 28, "Thread Count");
            uiPrefsOpenEXRThreadCount->tooltip("Use multiple threads when loading a frame.");
            uiPrefsOpenEXRThreadCount->minimum(1);
            uiPrefsOpenEXRThreadCount->maximum(16);
            uiPrefsOpenEXRThreadCount->step(1);
            uiPrefsOpenEXRThreadCount->value(4);
          } // Fl_Value_Input* uiPrefsOpenEXRThreadCount
          { uiPrefsOpenEXRGamma = new Fl_Value_Input(435, 162, 51, 28, "Gamma");
            uiPrefsOpenEXRGamma->tooltip("Gamma to use when loading an exr.");
            uiPrefsOpenEXRGamma->minimum(0.1);
            uiPrefsOpenEXRGamma->maximum(16);
            uiPrefsOpenEXRGamma->step(0.1);
            uiPrefsOpenEXRGamma->value(2.2);
          } // Fl_Value_Input* uiPrefsOpenEXRGamma
          o->end();
        } // Fl_Group* o
        { Fl_Group* o = new Fl_Group(275, 250, 330, 130, "Saving");
          o->box(FL_ROUNDED_BOX);
          o->labelsize(15);
          { uiPrefsOpenEXRCompression = new Fl_Choice(375, 270, 180, 25, "Compression");
            uiPrefsOpenEXRCompression->tooltip("Compression to use when saving an exr.");
            uiPrefsOpenEXRCompression->down_box(FL_BORDER_BOX);
            uiPrefsOpenEXRCompression->callback((Fl_Callback*)cb_uiPrefsOpenEXRCompression, (void*)(this));
            uiPrefsOpenEXRCompression->menu(menu_uiPrefsOpenEXRCompression);
          } // Fl_Choice* uiPrefsOpenEXRCompression
          { uiPrefsOpenEXRDWACompression = new Fl_Value_Slider(405, 311, 138, 34, "DWA Compression");
            uiPrefsOpenEXRDWACompression->tooltip("DWA/DWB compression to use when saving an exr with that compression scheme.");
            uiPrefsOpenEXRDWACompression->minimum(1);
            uiPrefsOpenEXRDWACompression->maximum(250);
            uiPrefsOpenEXRDWACompression->step(10);
            uiPrefsOpenEXRDWACompression->value(45);
            uiPrefsOpenEXRDWACompression->align(Fl_Align(FL_ALIGN_LEFT));
            uiPrefsOpenEXRDWACompression->deactivate();
          } // Fl_Value_Slider* uiPrefsOpenEXRDWACompression
          o->end();
        } // Fl_Group* o
        o->end();
      } // Fl_Group* o
      uiWizard->end();
    } // Fl_Wizard* uiWizard
    { Fl_Group* o = new Fl_Group(5, 5, 207, 430);
      { mrv::PreferencesBrowser* o = new mrv::PreferencesBrowser(5, 25, 195, 410, "Module");
        o->box(FL_NO_BOX);
        o->color(FL_BACKGROUND2_COLOR);
        o->selection_color(FL_SELECTION_COLOR);
        o->labeltype(FL_NORMAL_LABEL);
        o->labelfont(0);
        o->labelsize(14);
        o->labelcolor(FL_FOREGROUND_COLOR);
        o->callback((Fl_Callback*)cb_Module, (void*)(this));
        o->align(Fl_Align(FL_ALIGN_BOTTOM));
        o->when(FL_WHEN_RELEASE_ALWAYS);
      } // mrv::PreferencesBrowser* o
      o->end();
    } // Fl_Group* o
    { Fl_Group* o = new Fl_Group(223, 419, 427, 31);
      { Fl_Button* o = new Fl_Button(223, 422, 132, 27, "Revert");
        o->tooltip("Revert settings to last saved preferences.");
        o->callback((Fl_Callback*)cb_Revert, (void*)(this));
      } // Fl_Button* o
      { Fl_Button* o = new Fl_Button(358, 422, 132, 27, "Save");
        o->tooltip("Save preferences to disk as a default.");
        o->callback((Fl_Callback*)cb_Save);
      } // Fl_Button* o
      { Fl_Button* o = new Fl_Button(493, 422, 132, 27, "OK");
        o->tooltip("Accept settings but don\'t save.");
        o->callback((Fl_Callback*)cb_OK, (void*)(m));
      } // Fl_Button* o
      o->end();
    } // Fl_Group* o
    uiMain->end();
    uiMain->resizable(uiMain);
  } // Fl_Double_Window* uiMain
  return uiMain;
}

PreferencesUI::PreferencesUI(mrv::ViewerUI* m) {
  make_window(m);
}

PreferencesUI::~PreferencesUI() {
  delete uiMain; uiMain = NULL;
}

void PreferencesUI::refresh() {
  fltk::Window* w = fltk::Window::first();
  for ( ; w ; w = w->next() )
     w->redraw();
}

void PreferencesUI::run(mrv::ViewerUI* m) {
  mrv::Preferences::run( m );
  fltk::Window* w = fltk::Window::first();
  for ( ; w ; w = w->next() )
     w->redraw();
}

Fl_Double_Window* SaveOptionsUI::make_window(ViewerUI* main) {
  { Fl_Double_Window* o = uiMain = new Fl_Double_Window(315, 375, "Save Options");
    uiMain->user_data((void*)(this));
    { Fl_Group* o = new Fl_Group(8, 14, 302, 356);
      o->box(FL_EMBOSSED_BOX);
      { Fl_Group* o = new Fl_Group(24, 30, 275, 45);
        o->box(FL_ENGRAVED_BOX);
        o->end();
      } // Fl_Group* o
      { Fl_Group* o = new Fl_Group(24, 85, 275, 45);
        o->box(FL_ENGRAVED_BOX);
        o->end();
      } // Fl_Group* o
      { Fl_Group* o = new Fl_Group(24, 140, 275, 45);
        o->box(FL_ENGRAVED_BOX);
        o->end();
      } // Fl_Group* o
      { Fl_Group* o = new Fl_Group(24, 195, 275, 45);
        o->box(FL_ENGRAVED_BOX);
        o->end();
      } // Fl_Group* o
      { Fl_Group* o = new Fl_Group(24, 250, 275, 45);
        o->box(FL_ENGRAVED_BOX);
        o->end();
      } // Fl_Group* o
      { Fl_Group* o = new Fl_Group(144, 335, 150, 25);
        { new Fl_Return_Button(224, 335, 70, 25, "Save");
        } // Fl_Return_Button* o
        { new Fl_Button(144, 335, 70, 25, "Cancel");
        } // Fl_Button* o
        o->end();
      } // Fl_Group* o
      o->end();
    } // Fl_Group* o
    // Make the window transient
o->child_of( main->uiMain );
    uiMain->set_modal();
    uiMain->end();
    uiMain->resizable(uiMain);
  } // Fl_Double_Window* uiMain
  return uiMain;
}

SaveOptionsUI::SaveOptionsUI(ViewerUI* m) {
  make_window( m );
}

SaveOptionsUI::~SaveOptionsUI() {
  delete uiMain; uiMain = NULL;
}

Fl_Double_Window* StatisticsUI::make_window(ViewerUI* main) {
  { Fl_Double_Window* o = uiMain = new Fl_Double_Window(445, 235, "Statistics");
    uiMain->user_data((void*)(this));
    { Fl_Group* o = new Fl_Group(9, 5, 344, 218);
      { Fl_Group* o = new Fl_Group(229, 20, 200, 75, "Video");
        o->box(FL_BORDER_BOX);
        { uiVideoFramesDropped = new Fl_Value_Output(339, 60, 80, 25, "Dropped Frames");
        } // Fl_Value_Output* uiVideoFramesDropped
        { uiVideoBlocksDecoded = new Fl_Value_Output(339, 30, 80, 25, "Decoded Blocks");
        } // Fl_Value_Output* uiVideoBlocksDecoded
        o->end();
      } // Fl_Group* o
      { uiAVDifference = new Fl_Value_Output(339, 195, 80, 25, "A/V Difference");
      } // Fl_Value_Output* uiAVDifference
      { Fl_Group* o = new Fl_Group(229, 115, 200, 75, "Audio");
        o->box(FL_BORDER_BOX);
        { uiAudioFramesDropped = new Fl_Value_Output(339, 160, 80, 25, "Dropped Frames");
        } // Fl_Value_Output* uiAudioFramesDropped
        { uiAudioBlocksDecoded = new Fl_Value_Output(339, 130, 80, 25, "Decoded Blocks");
        } // Fl_Value_Output* uiAudioBlocksDecoded
        o->end();
      } // Fl_Group* o
      { Fl_Group* o = new Fl_Group(14, 20, 205, 75, "Input");
        o->box(FL_BORDER_BOX);
        { uiInputRead = new Fl_Value_Output(79, 30, 95, 25, "Read");
        } // Fl_Value_Output* uiInputRead
        { uiInputBitrate = new Fl_Value_Output(79, 60, 95, 25, "Bitrate");
        } // Fl_Value_Output* uiInputBitrate
        o->end();
      } // Fl_Group* o
      { Fl_Group* o = new Fl_Group(14, 115, 205, 100, "Streaming");
        o->box(FL_BORDER_BOX);
        { uiStreamSent = new Fl_Value_Output(79, 155, 95, 25, "Sent");
        } // Fl_Value_Output* uiStreamSent
        { uiStreamBitrate = new Fl_Value_Output(79, 185, 95, 25, "Bitrate");
        } // Fl_Value_Output* uiStreamBitrate
        { uiStreamPackets = new Fl_Value_Output(79, 125, 95, 25, "Packets");
        } // Fl_Value_Output* uiStreamPackets
        o->end();
      } // Fl_Group* o
      o->end();
    } // Fl_Group* o
    o->child_of( main->uiMain );
    uiMain->end();
    uiMain->resizable(uiMain);
  } // Fl_Double_Window* uiMain
  return uiMain;
}

StatisticsUI::StatisticsUI(ViewerUI* m) {
  make_window( m );
}

StatisticsUI::~StatisticsUI() {
  delete uiMain; uiMain = NULL;
}

void LogUI::cb_Save1_i(Fl_Button*, mrv::LogDisplay* v) {
  v->save();
}
void LogUI::cb_Save1(Fl_Button* o, mrv::LogDisplay* v) {
  ((LogUI*)(o->parent()->parent()->parent()->user_data()))->cb_Save1_i(o,v);
}

void LogUI::cb_Clear_i(Fl_Button*, mrv::LogDisplay* v) {
  v->clear();
}
void LogUI::cb_Clear(Fl_Button* o, mrv::LogDisplay* v) {
  ((LogUI*)(o->parent()->parent()->parent()->user_data()))->cb_Clear_i(o,v);
}

Fl_Double_Window* LogUI::make_window(ViewerUI* main) {
  { Fl_Double_Window* o = uiMain = new Fl_Double_Window(635, 250, "Log Messages");
    uiMain->user_data((void*)(this));
    { Fl_Group* o = new Fl_Group(5, 5, 630, 240);
      { uiLogText = new mrv::LogDisplay(5, 5, 625, 200);
        uiLogText->box(FL_DOWN_FRAME);
        uiLogText->color(FL_BACKGROUND2_COLOR);
        uiLogText->selection_color(FL_SELECTION_COLOR);
        uiLogText->labeltype(FL_NORMAL_LABEL);
        uiLogText->labelfont(0);
        uiLogText->labelsize(14);
        uiLogText->labelcolor(FL_FOREGROUND_COLOR);
        uiLogText->align(Fl_Align(FL_ALIGN_TOP));
        uiLogText->when(FL_WHEN_RELEASE);
        Fl_Group::current()->resizable(uiLogText);
      } // mrv::LogDisplay* uiLogText
      { Fl_Group* o = new Fl_Group(455, 205, 175, 40);
        { Fl_Button* o = new Fl_Button(545, 210, 75, 30, "Save");
          o->callback((Fl_Callback*)cb_Save1, (void*)(uiLogText));
        } // Fl_Button* o
        { Fl_Button* o = new Fl_Button(465, 210, 75, 30, "Clear");
          o->callback((Fl_Callback*)cb_Clear, (void*)(uiLogText));
        } // Fl_Button* o
        o->end();
      } // Fl_Group* o
      o->end();
      Fl_Group::current()->resizable(o);
    } // Fl_Group* o
    o->child_of( main->uiMain );
    uiMain->end();
  } // Fl_Double_Window* uiMain
  return uiMain;
}

LogUI::LogUI(ViewerUI* m) {
  make_window( m );
}

LogUI::~LogUI() {
  delete uiMain; uiMain = NULL;
}

void HotkeyUI::cb_uiFunction_i(Fl_Browser*, HotkeyUI* v) {
  mrv::select_hotkey( v );
}
void HotkeyUI::cb_uiFunction(Fl_Browser* o, HotkeyUI* v) {
  ((HotkeyUI*)(o->parent()->parent()->user_data()))->cb_uiFunction_i(o,v);
}

void HotkeyUI::cb_Save2_i(Fl_Button*, void*) {
  mrv::Preferences::save();
}
void HotkeyUI::cb_Save2(Fl_Button* o, void* v) {
  ((HotkeyUI*)(o->parent()->parent()->user_data()))->cb_Save2_i(o,v);
}

Fl_Double_Window* HotkeyUI::make_window(ViewerUI* main) {
  { Fl_Double_Window* o = uiMain = new Fl_Double_Window(450, 400, "Hotkeys");
    uiMain->user_data((void*)(this));
    { Fl_Group* o = new Fl_Group(5, 25, 445, 375);
      { Fl_Browser* o = uiFunction = new Fl_Browser(25, 25, 415, 315, "Function");
        uiFunction->callback((Fl_Callback*)cb_uiFunction, (void*)(this));
        mrv::fill_ui_hotkeys( o );
      } // Fl_Browser* uiFunction
      { Fl_Button* o = new Fl_Button(370, 355, 65, 30, "Save");
        o->callback((Fl_Callback*)cb_Save2);
      } // Fl_Button* o
      o->end();
    } // Fl_Group* o
    // Make the window transient
o->child_of( main->uiMain );
    uiMain->set_modal();
    uiMain->end();
    uiMain->resizable(uiMain);
  } // Fl_Double_Window* uiMain
  return uiMain;
}

HotkeyUI::HotkeyUI(ViewerUI* m) {
  make_window( m );
}

HotkeyUI::~HotkeyUI() {
  delete uiMain; uiMain = NULL;
}

void PaintUI::cb_uiSelection_i(Fl_Button* o, mrv::ViewerUI* v) {
  v->uiView->selection_mode();
o->value(1);
uiDraw->value(0);
uiErase->value(0);
uiText->value(0);
}
void PaintUI::cb_uiSelection(Fl_Button* o, mrv::ViewerUI* v) {
  ((PaintUI*)(o->parent()->parent()->user_data()))->cb_uiSelection_i(o,v);
}

void PaintUI::cb_uiDraw_i(Fl_Button* o, mrv::ViewerUI* v) {
  v->uiView->draw_mode();
o->value(1);
uiSelection->value(0);
uiErase->value(0);
uiText->value(0);
}
void PaintUI::cb_uiDraw(Fl_Button* o, mrv::ViewerUI* v) {
  ((PaintUI*)(o->parent()->parent()->user_data()))->cb_uiDraw_i(o,v);
}

void PaintUI::cb_uiErase_i(Fl_Button* o, mrv::ViewerUI* v) {
  v->uiView->erase_mode();
o->value(1);
uiSelection->value(0);
uiDraw->value(0);
uiText->value(0);
}
void PaintUI::cb_uiErase(Fl_Button* o, mrv::ViewerUI* v) {
  ((PaintUI*)(o->parent()->parent()->user_data()))->cb_uiErase_i(o,v);
}

void PaintUI::cb_uiText_i(Fl_Button* o, mrv::ViewerUI* v) {
  o->value(1);
v->uiView->text_mode();
}
void PaintUI::cb_uiText(Fl_Button* o, mrv::ViewerUI* v) {
  ((PaintUI*)(o->parent()->parent()->user_data()))->cb_uiText_i(o,v);
}

void PaintUI::cb_uiUndoDraw_i(Fl_Button* o, mrv::ViewerUI* v) {
  v->uiView->undo_draw();

if ( !v->uiView->has_undo() )
 o->deactivate();
}
void PaintUI::cb_uiUndoDraw(Fl_Button* o, mrv::ViewerUI* v) {
  ((PaintUI*)(o->parent()->parent()->parent()->user_data()))->cb_uiUndoDraw_i(o,v);
}

void PaintUI::cb_uiRedoDraw_i(Fl_Button* o, mrv::ViewerUI* v) {
  v->uiView->redo_draw();
if ( !v->uiView->has_redo() )
   o->deactivate();
else
   o->activate();
}
void PaintUI::cb_uiRedoDraw(Fl_Button* o, mrv::ViewerUI* v) {
  ((PaintUI*)(o->parent()->parent()->parent()->user_data()))->cb_uiRedoDraw_i(o,v);
}

void PaintUI::cb_uiPenColor_i(Fl_Button* o, void*) {
  uchar r, g, b;
fltk::split_color(o->color(),r,g,b);
if (!fltk::color_chooser("Pick Draw Color", r,g,b)) return;
if ( r == 0 && g == 0 && b == 0 )
  o->color( fltk::BLACK );
else
  o->color( fltk::color( r,g,b ) );
o->redraw();
}
void PaintUI::cb_uiPenColor(Fl_Button* o, void* v) {
  ((PaintUI*)(o->parent()->parent()->user_data()))->cb_uiPenColor_i(o,v);
}

void PaintUI::cb_Previous_i(Fl_Check_Button* o, mrv::ViewerUI* v) {
  v->uiView->ghost_previous( o->value() );
v->uiView->redraw();
}
void PaintUI::cb_Previous(Fl_Check_Button* o, mrv::ViewerUI* v) {
  ((PaintUI*)(o->parent()->parent()->parent()->user_data()))->cb_Previous_i(o,v);
}

void PaintUI::cb_Next_i(Fl_Check_Button* o, mrv::ViewerUI* v) {
  v->uiView->ghost_next( o->value() );
v->uiView->redraw();
}
void PaintUI::cb_Next(Fl_Check_Button* o, mrv::ViewerUI* v) {
  ((PaintUI*)(o->parent()->parent()->parent()->user_data()))->cb_Next_i(o,v);
}

Fl_Double_Window* PaintUI::make_window( ViewerUI* m ) {
  { uiMain = new Fl_Double_Window(155, 395, "Paint");
    uiMain->user_data((void*)(this));
    { Fl_Group* o = new Fl_Group(0, 9, 149, 376);
      { Fl_Button* o = uiSelection = new Fl_Button(29, 24, 43, 35);
        uiSelection->tooltip("Area Select Tool");
        uiSelection->value(1);
        uiSelection->callback((Fl_Callback*)cb_uiSelection, (void*)(m));
        o->value(1);
o->image( select_pic );
      } // Fl_Button* uiSelection
      { Fl_Button* o = uiDraw = new Fl_Button(77, 24, 40, 35);
        uiDraw->tooltip("Freehand Drawing Tool");
        uiDraw->callback((Fl_Callback*)cb_uiDraw, (void*)(m));
        o->image( draw );
      } // Fl_Button* uiDraw
      { Fl_Button* o = uiErase = new Fl_Button(77, 65, 40, 35);
        uiErase->tooltip("Eraser Tool");
        uiErase->callback((Fl_Callback*)cb_uiErase, (void*)(m));
        o->image( erase );
      } // Fl_Button* uiErase
      { uiText = new Fl_Button(28, 64, 45, 35, "T");
        uiText->tooltip("Text Tool");
        uiText->labelfont(8);
        uiText->labelsize(24);
        uiText->callback((Fl_Callback*)cb_uiText, (void*)(m));
        uiText->align(Fl_Align(FL_ALIGN_TEXT_OVER_IMAGE));
      } // Fl_Button* uiText
      { uiPenSize = new Fl_Value_Slider(32, 115, 85, 30, "Pen Size");
        uiPenSize->tooltip("Selects the size of brush.");
        uiPenSize->minimum(1);
        uiPenSize->maximum(10);
        uiPenSize->step(1);
        uiPenSize->value(5);
        uiPenSize->align(Fl_Align(FL_ALIGN_TOP));
      } // Fl_Value_Slider* uiPenSize
      { Fl_Group* o = new Fl_Group(30, 345, 82, 40);
        { Fl_Button* o = uiUndoDraw = new Fl_Button(35, 347, 34, 35);
          uiUndoDraw->tooltip("Undo Last Shape Drawn");
          uiUndoDraw->callback((Fl_Callback*)cb_uiUndoDraw, (void*)(m));
          o->image( undo );
if ( !m->uiView->has_undo() )
 o->deactivate();
else
 o->activate();
        } // Fl_Button* uiUndoDraw
        { Fl_Button* o = uiRedoDraw = new Fl_Button(75, 347, 34, 35);
          uiRedoDraw->tooltip("Redo Previous Shape Drawn");
          uiRedoDraw->callback((Fl_Callback*)cb_uiRedoDraw, (void*)(m));
          o->image( redo );
if ( !m->uiView->has_redo() )
   o->deactivate();
else
   o->activate();
        } // Fl_Button* uiRedoDraw
        o->end();
      } // Fl_Group* o
      { uiPenColor = new Fl_Button(87, 160, 25, 25, "Pen Color");
        uiPenColor->tooltip("Selects the current pen color.");
        uiPenColor->box(FL_EMBOSSED_BOX);
        uiPenColor->color((Fl_Color)167706624);
        uiPenColor->labelsize(11);
        uiPenColor->callback((Fl_Callback*)cb_uiPenColor);
        uiPenColor->align(Fl_Align(FL_ALIGN_LEFT));
      } // Fl_Button* uiPenColor
      { Fl_Group* o = new Fl_Group(25, 205, 95, 55, "Frames");
        o->box(FL_UP_BOX);
        { uiAllFrames = new Fl_Round_Button(35, 210, 25, 25, "All");
          uiAllFrames->tooltip("Draw shape in all frames");
          uiAllFrames->down_box(FL_ROUND_DOWN_BOX);
        } // Fl_Round_Button* uiAllFrames
        { uiCurrentFrame = new Fl_Round_Button(35, 230, 25, 25, "Current");
          uiCurrentFrame->tooltip("Draw shape in curent frame only");
          uiCurrentFrame->down_box(FL_ROUND_DOWN_BOX);
          uiCurrentFrame->value(1);
        } // Fl_Round_Button* uiCurrentFrame
        o->end();
      } // Fl_Group* o
      { Fl_Group* o = new Fl_Group(25, 275, 95, 60, "Ghosting");
        o->box(FL_UP_BOX);
        { Fl_Check_Button* o = new Fl_Check_Button(35, 280, 25, 25, "Previous");
          o->tooltip("Show shapes of previous frame ghosted.");
          o->down_box(FL_DOWN_BOX);
          o->value(1);
          o->callback((Fl_Callback*)cb_Previous, (void*)(m));
        } // Fl_Check_Button* o
        { Fl_Check_Button* o = new Fl_Check_Button(35, 300, 25, 25, "Next");
          o->tooltip("Show next frame shapes ghosted.");
          o->down_box(FL_DOWN_BOX);
          o->value(1);
          o->callback((Fl_Callback*)cb_Next, (void*)(m));
        } // Fl_Check_Button* o
        o->end();
      } // Fl_Group* o
      o->end();
    } // Fl_Group* o
    uiMain->end();
    uiMain->resizable(uiMain);
  } // Fl_Double_Window* uiMain
  return uiMain;
}

PaintUI::PaintUI(ViewerUI* m) {
  make_window( m );
}

PaintUI::~PaintUI() {
  delete uiMain; uiMain = NULL;
}

void ConnectionUI::cb_uiCreate_i(Fl_Button* o, mrv::ViewerUI* v) {
  if ( strcmp( o->label(), "Create" ) == 0 )
    mrv::server::create(v);
else
    mrv::server::remove(v);
}
void ConnectionUI::cb_uiCreate(Fl_Button* o, mrv::ViewerUI* v) {
  ((ConnectionUI*)(o->parent()->parent()->parent()->user_data()))->cb_uiCreate_i(o,v);
}

void ConnectionUI::cb_uiConnect_i(Fl_Button* o, mrv::ViewerUI* v) {
  if ( strcmp( o->label(), "Connect" ) == 0 )
   mrv::client::create(v);
else
   mrv::client::remove(v);
}
void ConnectionUI::cb_uiConnect(Fl_Button* o, mrv::ViewerUI* v) {
  ((ConnectionUI*)(o->parent()->parent()->parent()->user_data()))->cb_uiConnect_i(o,v);
}

Fl_Double_Window* ConnectionUI::make_window(ViewerUI* main) {
  { Fl_Double_Window* o = uiMain = new Fl_Double_Window(450, 400, "Connections");
    uiMain->user_data((void*)(this));
    { Fl_Group* o = new Fl_Group(0, 5, 445, 390);
      { uiServerGroup = new Fl_Group(15, 15, 400, 75, "Server");
        uiServerGroup->box(FL_ROUNDED_BOX);
        uiServerGroup->align(Fl_Align(FL_ALIGN_TOP_LEFT));
        { uiServerPort = new Fl_Value_Input(130, 40, 70, 25, "Port");
          uiServerPort->step(1);
          uiServerPort->value(4333);
        } // Fl_Value_Input* uiServerPort
        { uiCreate = new Fl_Button(210, 40, 100, 25, "Create");
          uiCreate->callback((Fl_Callback*)cb_uiCreate, (void*)(main));
        } // Fl_Button* uiCreate
        uiServerGroup->end();
      } // Fl_Group* uiServerGroup
      { uiClientGroup = new Fl_Group(15, 110, 400, 70, "Client");
        uiClientGroup->box(FL_ROUNDED_BOX);
        uiClientGroup->align(Fl_Align(FL_ALIGN_TOP_LEFT));
        { Fl_Input* o = uiClientServer = new Fl_Input(80, 128, 115, 30, "Server");
          o->text("localhost");
        } // Fl_Input* uiClientServer
        { uiClientPort = new Fl_Value_Input(250, 130, 70, 25, "Port");
          uiClientPort->step(1);
          uiClientPort->value(4333);
        } // Fl_Value_Input* uiClientPort
        { uiConnect = new Fl_Button(325, 130, 85, 25, "Connect");
          uiConnect->callback((Fl_Callback*)cb_uiConnect, (void*)(main));
        } // Fl_Button* uiConnect
        uiClientGroup->end();
      } // Fl_Group* uiClientGroup
      { Fl_Group* o = new Fl_Group(15, 190, 400, 200);
        o->box(FL_ROUNDED_BOX);
        { uiLog = new mrv::LogDisplay(30, 195, 375, 190);
          uiLog->box(FL_FLAT_BOX);
          uiLog->color(FL_BACKGROUND2_COLOR);
          uiLog->selection_color(FL_SELECTION_COLOR);
          uiLog->labeltype(FL_NORMAL_LABEL);
          uiLog->labelfont(0);
          uiLog->labelsize(14);
          uiLog->labelcolor(FL_FOREGROUND_COLOR);
          uiLog->align(Fl_Align(FL_ALIGN_TOP));
          uiLog->when(FL_WHEN_RELEASE);
        } // mrv::LogDisplay* uiLog
        o->end();
      } // Fl_Group* o
      o->end();
    } // Fl_Group* o
    // Make the window transient
o->child_of( main->uiMain );
    uiMain->end();
    uiMain->resizable(uiMain);
  } // Fl_Double_Window* uiMain
  return uiMain;
}

ConnectionUI::ConnectionUI(ViewerUI* m) {
  make_window( m );
}

ConnectionUI::~ConnectionUI() {
  delete uiMain; uiMain = NULL;
}

void ViewerUI::cb_uiMain3_i(mrv::MainWindow*, mrv::ViewerUI* v) {
  delete v;
}
void ViewerUI::cb_uiMain3(mrv::MainWindow* o, mrv::ViewerUI* v) {
  ((ViewerUI*)(o->user_data()))->cb_uiMain3_i(o,v);
}

void ViewerUI::cb_uiGainInput_i(Fl_Value_Input* o, mrv::ViewerUI* v) {
  v->uiView->gain( (float) o->value() );
v->uiGain->value( (float) o->value() );
}
void ViewerUI::cb_uiGainInput(Fl_Value_Input* o, mrv::ViewerUI* v) {
  ((ViewerUI*)(o->parent()->parent()->parent()->parent()->parent()->user_data()))->cb_uiGainInput_i(o,v);
}

void ViewerUI::cb_uiGain_i(Fl_Slider* o, mrv::ViewerUI* v) {
  v->uiView->gain( (float) o->value() );
v->uiGainInput->value( (float) o->value() );
}
void ViewerUI::cb_uiGain(Fl_Slider* o, mrv::ViewerUI* v) {
  ((ViewerUI*)(o->parent()->parent()->parent()->parent()->parent()->user_data()))->cb_uiGain_i(o,v);
}

void ViewerUI::cb_9_i(Fl_Button*, mrv::ViewerUI* v) {
  v->uiView->exposure_change(-0.5f);
}
void ViewerUI::cb_9(Fl_Button* o, mrv::ViewerUI* v) {
  ((ViewerUI*)(o->parent()->parent()->parent()->parent()->parent()->parent()->user_data()))->cb_9_i(o,v);
}

void ViewerUI::cb_uiFstop_i(Fl_Button*, mrv::ViewerUI* v) {
  static float old_gain = 1.0f;
float gain = v->uiView->gain();
if ( gain == 1.0f )
{
v->uiView->gain( old_gain );
v->uiGainInput->value( old_gain );
v->uiGain->value( old_gain );
}
else
{
old_gain = gain;
v->uiView->gain( 1.0f );
v->uiGain->value( 1.0f );
v->uiGainInput->value( 1.0f );
};
}
void ViewerUI::cb_uiFstop(Fl_Button* o, mrv::ViewerUI* v) {
  ((ViewerUI*)(o->parent()->parent()->parent()->parent()->parent()->parent()->user_data()))->cb_uiFstop_i(o,v);
}

void ViewerUI::cb_a_i(Fl_Button*, mrv::ViewerUI* v) {
  v->uiView->exposure_change(0.5f);
}
void ViewerUI::cb_a(Fl_Button* o, mrv::ViewerUI* v) {
  ((ViewerUI*)(o->parent()->parent()->parent()->parent()->parent()->parent()->user_data()))->cb_a_i(o,v);
}

void ViewerUI::cb_uiNormalize_i(Fl_Button*, mrv::ViewerUI* v) {
  v->uiView->toggle_normalize();
}
void ViewerUI::cb_uiNormalize(Fl_Button* o, mrv::ViewerUI* v) {
  ((ViewerUI*)(o->parent()->parent()->parent()->parent()->parent()->user_data()))->cb_uiNormalize_i(o,v);
}

void ViewerUI::cb_uiGammaInput_i(Fl_Value_Input* o, mrv::ViewerUI* v) {
  v->uiView->gamma( (float) o->value() );
v->uiGamma->value( (float) o->value() );
}
void ViewerUI::cb_uiGammaInput(Fl_Value_Input* o, mrv::ViewerUI* v) {
  ((ViewerUI*)(o->parent()->parent()->parent()->parent()->parent()->parent()->user_data()))->cb_uiGammaInput_i(o,v);
}

void ViewerUI::cb_uiGamma_i(Fl_Slider* o, mrv::ViewerUI* v) {
  v->uiView->gamma( (float) o->value() );
v->uiGammaInput->value( (float) o->value() );
}
void ViewerUI::cb_uiGamma(Fl_Slider* o, mrv::ViewerUI* v) {
  ((ViewerUI*)(o->parent()->parent()->parent()->parent()->parent()->parent()->user_data()))->cb_uiGamma_i(o,v);
}

void ViewerUI::cb_uiPixelRatio_i(Fl_Button*, mrv::ViewerUI* v) {
  v->uiView->toggle_pixel_ratio();
}
void ViewerUI::cb_uiPixelRatio(Fl_Button* o, mrv::ViewerUI* v) {
  ((ViewerUI*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_uiPixelRatio_i(o,v);
}

void ViewerUI::cb_uiLUT_i(Fl_Button*, mrv::ViewerUI* v) {
  v->uiView->toggle_lut();
}
void ViewerUI::cb_uiLUT(Fl_Button* o, mrv::ViewerUI* v) {
  ((ViewerUI*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_uiLUT_i(o,v);
}

void ViewerUI::cb_uiTimeline_i(mrv::Timeline* o, mrv::ViewerUI* v) {
  int64_t frame = (int64_t) o->value();
v->uiView->seek( frame );
}
void ViewerUI::cb_uiTimeline(mrv::Timeline* o, mrv::ViewerUI* v) {
  ((ViewerUI*)(o->parent()->parent()->parent()->parent()->parent()->user_data()))->cb_uiTimeline_i(o,v);
}

void ViewerUI::cb_uiFrame_i(mrv::Timecode* o, mrv::ViewerUI* v) {
  int64_t f = o->value();
if ( f < v->uiTimeline->minimum() )
   f = int64_t( v->uiTimeline->minimum() );
else if ( f > v->uiTimeline->maximum() )
   f = int64_t( v->uiTimeline->maximum() );
v->uiView->seek( f );
}
void ViewerUI::cb_uiFrame(mrv::Timecode* o, mrv::ViewerUI* v) {
  ((ViewerUI*)(o->parent()->parent()->parent()->parent()->parent()->parent()->parent()->user_data()))->cb_uiFrame_i(o,v);
}

void ViewerUI::cb_b_i(Fl_Button*, mrv::ViewerUI* v) {
  v->uiView->first_frame();
}
void ViewerUI::cb_b(Fl_Button* o, mrv::ViewerUI* v) {
  ((ViewerUI*)(o->parent()->parent()->parent()->parent()->parent()->parent()->parent()->parent()->user_data()))->cb_b_i(o,v);
}

void ViewerUI::cb_uiPlayBackwards_i(Fl_Button*, mrv::ViewerUI* v) {
  v->uiView->play_backwards();
}
void ViewerUI::cb_uiPlayBackwards(Fl_Button* o, mrv::ViewerUI* v) {
  ((ViewerUI*)(o->parent()->parent()->parent()->parent()->parent()->parent()->parent()->parent()->user_data()))->cb_uiPlayBackwards_i(o,v);
}

void ViewerUI::cb_c_i(Fl_Button*, mrv::ViewerUI* v) {
  v->uiView->step_frame(-1);
}
void ViewerUI::cb_c(Fl_Button* o, mrv::ViewerUI* v) {
  ((ViewerUI*)(o->parent()->parent()->parent()->parent()->parent()->parent()->parent()->parent()->user_data()))->cb_c_i(o,v);
}

void ViewerUI::cb_d_i(Fl_Button*, mrv::ViewerUI* v) {
  v->uiView->stop();
}
void ViewerUI::cb_d(Fl_Button* o, mrv::ViewerUI* v) {
  ((ViewerUI*)(o->parent()->parent()->parent()->parent()->parent()->parent()->parent()->parent()->user_data()))->cb_d_i(o,v);
}

void ViewerUI::cb_e_i(Fl_Button*, mrv::ViewerUI* v) {
  v->uiView->step_frame(1);
}
void ViewerUI::cb_e(Fl_Button* o, mrv::ViewerUI* v) {
  ((ViewerUI*)(o->parent()->parent()->parent()->parent()->parent()->parent()->parent()->parent()->user_data()))->cb_e_i(o,v);
}

void ViewerUI::cb_uiPlayForwards_i(Fl_Button*, mrv::ViewerUI* v) {
  v->uiView->play_forwards();
}
void ViewerUI::cb_uiPlayForwards(Fl_Button* o, mrv::ViewerUI* v) {
  ((ViewerUI*)(o->parent()->parent()->parent()->parent()->parent()->parent()->parent()->parent()->user_data()))->cb_uiPlayForwards_i(o,v);
}

void ViewerUI::cb_f_i(Fl_Button*, mrv::ViewerUI* v) {
  v->uiView->last_frame();
}
void ViewerUI::cb_f(Fl_Button* o, mrv::ViewerUI* v) {
  ((ViewerUI*)(o->parent()->parent()->parent()->parent()->parent()->parent()->parent()->parent()->user_data()))->cb_f_i(o,v);
}

void ViewerUI::cb_uiFPS_i(fltk::ValueInput* o, mrv::ViewerUI* v) {
  v->uiView->fps( o->value() );
}
void ViewerUI::cb_uiFPS(fltk::ValueInput* o, mrv::ViewerUI* v) {
  ((ViewerUI*)(o->parent()->parent()->parent()->parent()->parent()->parent()->parent()->parent()->user_data()))->cb_uiFPS_i(o,v);
}

void ViewerUI::cb_uiVolume_i(Fl_Slider* o, mrv::ViewerUI* v) {
  v->uiView->volume((float) o->value() );
}
void ViewerUI::cb_uiVolume(Fl_Slider* o, mrv::ViewerUI* v) {
  ((ViewerUI*)(o->parent()->parent()->parent()->parent()->parent()->parent()->parent()->parent()->user_data()))->cb_uiVolume_i(o,v);
}

void ViewerUI::cb_uiStartFrame_i(mrv::Timecode* o, mrv::ViewerUI* v) {
  double f = (double) o->value();
v->uiTimeline->minimum( f );
v->uiTimeToolbar->redraw();
v->uiTimeline->redraw();
}
void ViewerUI::cb_uiStartFrame(mrv::Timecode* o, mrv::ViewerUI* v) {
  ((ViewerUI*)(o->parent()->parent()->parent()->parent()->parent()->parent()->parent()->user_data()))->cb_uiStartFrame_i(o,v);
}

void ViewerUI::cb_uiEndFrame_i(mrv::Timecode* o, mrv::ViewerUI* v) {
  boost::int64_t f = o->value();
v->uiTimeline->maximum( float(f) );
v->uiTimeToolbar->redraw();
v->uiTimeline->redraw();
}
void ViewerUI::cb_uiEndFrame(mrv::Timecode* o, mrv::ViewerUI* v) {
  ((ViewerUI*)(o->parent()->parent()->parent()->parent()->parent()->parent()->parent()->user_data()))->cb_uiEndFrame_i(o,v);
}

void ViewerUI::cb_uiStartButton_i(Fl_Button* o, mrv::ViewerUI* v) {
  double f;
Image_ptr img = NULL;
mrv::media fg = v->uiView->foreground();
if ( fg )
{
  img = fg->image();
}


if ( !o->value() )
{
  o->value(1);
  f = (double) v->uiFrame->value();
}
else
{
  o->value(0);
  f = img->first_frame();
}

v->uiStartFrame->value( f );
v->uiTimeline->minimum( f );
v->uiTimeToolbar->redraw();
v->uiTimeline->redraw();
}
void ViewerUI::cb_uiStartButton(Fl_Button* o, mrv::ViewerUI* v) {
  ((ViewerUI*)(o->parent()->parent()->parent()->parent()->parent()->parent()->parent()->user_data()))->cb_uiStartButton_i(o,v);
}

void ViewerUI::cb_uiEndButton_i(Fl_Button* o, mrv::ViewerUI* v) {
  double f;
if ( !o->value() )
{
  o->value(1);
  f = (double) v->uiFrame->value();
}
else
{
  o->value(0);
  mrv::media fg = v->uiView->foreground();
  if ( fg )
  {
    Image_ptr img = fg->image();
    f = img->last_frame();
  }
}

v->uiEndFrame->value( f );
v->uiTimeline->maximum( f );
v->uiTimeToolbar->redraw();
v->uiTimeline->redraw();
}
void ViewerUI::cb_uiEndButton(Fl_Button* o, mrv::ViewerUI* v) {
  ((ViewerUI*)(o->parent()->parent()->parent()->parent()->parent()->parent()->parent()->user_data()))->cb_uiEndButton_i(o,v);
}

mrv::MainWindow* ViewerUI::make_window() {
  uiPrefs = new PreferencesUI(this);
  { mrv::MainWindow* o = uiMain = new mrv::MainWindow(640, 535, "mrViewer");
    uiMain->box(FL_FLAT_BOX);
    uiMain->color(FL_BACKGROUND_COLOR);
    uiMain->selection_color(FL_BACKGROUND_COLOR);
    uiMain->labeltype(FL_NO_LABEL);
    uiMain->labelfont(0);
    uiMain->labelsize(14);
    uiMain->labelcolor(FL_FOREGROUND_COLOR);
    uiMain->callback((Fl_Callback*)cb_uiMain3, (void*)(this));
    uiMain->align(Fl_Align(FL_ALIGN_TOP));
    uiMain->when(FL_WHEN_RELEASE);
    { uiRegion = new Fl_Pack(0, 0, 640, 530);
      { uiTopBar = new Fl_Group(0, 0, 640, 28);
        uiTopBar->box(FL_ENGRAVED_BOX);
        { Fl_Group* o = new Fl_Group(30, 5, 90, 20);
          o->color((Fl_Color)1397969664);
          o->end();
        } // Fl_Group* o
        { Fl_Group* o = new Fl_Group(130, 5, 264, 20);
          o->color((Fl_Color)1397969664);
          { Fl_Group* o = new Fl_Group(130, 5, 264, 20);
            { Fl_Value_Input* o = uiGainInput = new Fl_Value_Input(160, 5, 35, 18);
              uiGainInput->tooltip("Gain image value.  A simple multiplier of the image pixel values.");
              uiGainInput->color((Fl_Color)-1733777408);
              uiGainInput->selection_color(FL_FOREGROUND_COLOR);
              uiGainInput->minimum(0.01);
              uiGainInput->maximum(1024);
              uiGainInput->step(0.001);
              uiGainInput->value(1);
              uiGainInput->callback((Fl_Callback*)cb_uiGainInput, (void*)(this));
              o->textsize( 12 );
            } // Fl_Value_Input* uiGainInput
            { uiGain = new Fl_Slider(195, 5, 70, 18);
              uiGain->tooltip("Allows you to adjust the gain or exposure of the image.");
              uiGain->minimum(0.015625);
              uiGain->maximum(64);
              uiGain->value(1);
              uiGain->slider_size(1);
              uiGain->callback((Fl_Callback*)cb_uiGain, (void*)(this));
            } // Fl_Slider* uiGain
            { Fl_Group* o = new Fl_Group(265, 5, 95, 19);
              { Fl_Button* o = new Fl_Button(265, 5, 16, 19, "@<");
                o->tooltip("Decrease exposure by 0.5.");
                o->callback((Fl_Callback*)cb_9, (void*)(this));
              } // Fl_Button* o
              { Fl_Button* o = uiFstop = new Fl_Button(280, 5, 64, 19, "+0.0  f/8.0");
                uiFstop->tooltip("Displays gain as film exposure and fstop.\nClick to toggle between current an\
d normal exposure.");
                uiFstop->labelfont(1);
                uiFstop->callback((Fl_Callback*)cb_uiFstop, (void*)(this));
                o->labelsize( 12 );
              } // Fl_Button* uiFstop
              { Fl_Button* o = new Fl_Button(344, 5, 16, 19, "@>");
                o->tooltip("Increase exposure by 0.5.");
                o->callback((Fl_Callback*)cb_a, (void*)(this));
              } // Fl_Button* o
              o->end();
            } // Fl_Group* o
            { uiNormalize = new Fl_Button(363, 5, 30, 19, "Norm");
              uiNormalize->tooltip("Normalize pixel values to remain in [0,1] range.");
              uiNormalize->callback((Fl_Callback*)cb_uiNormalize, (void*)(this));
            } // Fl_Button* uiNormalize
            o->end();
          } // Fl_Group* o
          o->end();
        } // Fl_Group* o
        { Fl_Group* o = new Fl_Group(405, 5, 155, 20);
          o->color((Fl_Color)1397969664);
          { Fl_Group* o = new Fl_Group(405, 5, 155, 20);
            { Fl_Group* o = new Fl_Group(405, 5, 155, 20);
              { Fl_Value_Input* o = uiGammaInput = new Fl_Value_Input(455, 5, 35, 18);
                uiGammaInput->tooltip("Allows you to adjust gamma curve for display.\nValue is:  pow( 2, 1/x );");
                uiGammaInput->color((Fl_Color)-1733777408);
                uiGammaInput->selection_color(FL_FOREGROUND_COLOR);
                uiGammaInput->minimum(0.015625);
                uiGammaInput->maximum(64);
                uiGammaInput->step(0.01);
                uiGammaInput->value(1);
                uiGammaInput->callback((Fl_Callback*)cb_uiGammaInput, (void*)(this));
                o->textsize(12);
              } // Fl_Value_Input* uiGammaInput
              { uiGamma = new Fl_Slider(490, 5, 60, 18);
                uiGamma->tooltip("Allows you to adjust gamma curve for display.\nValue is:  pow( 2, 1/x );");
                uiGamma->minimum(0.25);
                uiGamma->maximum(4);
                uiGamma->step(0.01);
                uiGamma->value(0.25);
                uiGamma->slider_size(1);
                uiGamma->callback((Fl_Callback*)cb_uiGamma, (void*)(this));
              } // Fl_Slider* uiGamma
              o->end();
            } // Fl_Group* o
            o->end();
          } // Fl_Group* o
          o->end();
        } // Fl_Group* o
        { Fl_Group* o = new Fl_Group(550, 5, 80, 20);
          { uiPixelRatio = new Fl_Button(570, 5, 30, 20, "1:1");
            uiPixelRatio->tooltip("Stretch image to compensate for image\'s pixel ratio.");
            uiPixelRatio->shortcut(0x40070);
            uiPixelRatio->callback((Fl_Callback*)cb_uiPixelRatio, (void*)(this));
          } // Fl_Button* uiPixelRatio
          { uiLUT = new Fl_Button(600, 5, 30, 20, "LUT");
            uiLUT->tooltip("Activate viewer\'s 3D Lut.");
            uiLUT->shortcut(0x74);
            uiLUT->callback((Fl_Callback*)cb_uiLUT, (void*)(this));
          } // Fl_Button* uiLUT
          o->end();
        } // Fl_Group* o
        uiTopBar->end();
      } // Fl_Group* uiTopBar
      { uiViewGroup = new fltk::Group(0, 28, 640, 430);
        uiViewGroup->box(FL_NO_BOX);
        uiViewGroup->color(FL_BACKGROUND_COLOR);
        uiViewGroup->selection_color(FL_BACKGROUND_COLOR);
        uiViewGroup->labeltype(FL_NORMAL_LABEL);
        uiViewGroup->labelfont(0);
        uiViewGroup->labelsize(14);
        uiViewGroup->labelcolor(FL_FOREGROUND_COLOR);
        uiViewGroup->align(Fl_Align(FL_ALIGN_TOP));
        uiViewGroup->when(FL_WHEN_RELEASE);
        { mrv::ImageView* o = uiView = new mrv::ImageView(0, 28, 640, 430);
          uiView->box(FL_NO_BOX);
          uiView->color(FL_BACKGROUND_COLOR);
          uiView->selection_color(FL_BACKGROUND_COLOR);
          uiView->labeltype(FL_NORMAL_LABEL);
          uiView->labelfont(0);
          uiView->labelsize(14);
          uiView->labelcolor(FL_FOREGROUND_COLOR);
          uiView->align(Fl_Align(FL_ALIGN_TOP));
          uiView->when(FL_WHEN_RELEASE);
          o->main(this);
          uiView->end();
        } // mrv::ImageView* uiView
        uiViewGroup->end();
        Fl_Group::current()->resizable(uiViewGroup);
      } // fltk::Group* uiViewGroup
      { uiPixelBar = new Fl_Group(0, 458, 640, 28);
        uiPixelBar->box(FL_FLAT_BOX);
        uiPixelBar->color(FL_BLACK);
        { Fl_Group* o = new Fl_Group(2, 458, 634, 25);
          { Fl_Group* o = new Fl_Group(31, 458, 605, 25);
            { uiCoord = new Fl_Output(31, 461, 85, 20, "XY");
              uiCoord->tooltip("Image coordinate of pixel under mouse.");
              uiCoord->box(FL_NO_BOX);
              uiCoord->color(FL_BLACK);
              uiCoord->labelfont(4);
              uiCoord->labelsize(10);
              uiCoord->textsize(10);
              uiCoord->align(Fl_Align(36));
            } // Fl_Output* uiCoord
            { Fl_Group* o = new Fl_Group(116, 458, 520, 25);
              { Fl_Group* o = new Fl_Group(116, 458, 520, 25);
                { Fl_Group* o = new Fl_Group(116, 461, 230, 22);
                { uiPixelR = new Fl_Output(146, 461, 50, 22);
                uiPixelR->tooltip("Red value of image pixel under mouse.");
                uiPixelR->box(FL_NO_BOX);
                uiPixelR->color(FL_BLACK);
                uiPixelR->textsize(10);
                uiPixelR->align(Fl_Align(36));
                } // Fl_Output* uiPixelR
                { uiPixelG = new Fl_Output(196, 461, 50, 22);
                uiPixelG->tooltip("Green value of image pixel under mouse.");
                uiPixelG->box(FL_NO_BOX);
                uiPixelG->color(FL_BLACK);
                uiPixelG->textsize(10);
                uiPixelG->align(Fl_Align(36));
                } // Fl_Output* uiPixelG
                { uiPixelB = new Fl_Output(246, 461, 50, 22);
                uiPixelB->tooltip("Blue value of image pixel under mouse.");
                uiPixelB->box(FL_NO_BOX);
                uiPixelB->color(FL_BLACK);
                uiPixelB->textsize(10);
                uiPixelB->align(Fl_Align(36));
                } // Fl_Output* uiPixelB
                { uiPixelA = new Fl_Output(296, 461, 50, 22);
                uiPixelA->tooltip("Alpha value of image pixel under mouse.");
                uiPixelA->box(FL_NO_BOX);
                uiPixelA->color(FL_BLACK);
                uiPixelA->textsize(10);
                uiPixelA->align(Fl_Align(36));
                } // Fl_Output* uiPixelA
                o->end();
                } // Fl_Group* o
                { uiPixelView = new Fl_Output(365, 460, 20, 20);
                uiPixelView->tooltip("8-bit sample of image pixel under mouse.");
                uiPixelView->box(FL_FLAT_BOX);
                uiPixelView->color((Fl_Color)1397969664);
                } // Fl_Output* uiPixelView
                { Fl_Group* o = new Fl_Group(391, 461, 173, 22);
                { uiPixelH = new Fl_Output(414, 461, 50, 22);
                uiPixelH->tooltip("Hue value of image pixel under mouse.");
                uiPixelH->box(FL_NO_BOX);
                uiPixelH->color(FL_BLACK);
                uiPixelH->textsize(10);
                uiPixelH->align(Fl_Align(36));
                } // Fl_Output* uiPixelH
                { uiPixelS = new Fl_Output(464, 461, 50, 22);
                uiPixelS->tooltip("Saturation value of image pixel under mouse.");
                uiPixelS->box(FL_NO_BOX);
                uiPixelS->color(FL_BLACK);
                uiPixelS->textsize(10);
                uiPixelS->align(Fl_Align(36));
                } // Fl_Output* uiPixelS
                { uiPixelV = new Fl_Output(514, 461, 50, 22);
                uiPixelV->tooltip("Value (Intensity) of image pixel under mouse.");
                uiPixelV->box(FL_NO_BOX);
                uiPixelV->color(FL_BLACK);
                uiPixelV->textsize(10);
                uiPixelV->align(Fl_Align(36));
                } // Fl_Output* uiPixelV
                o->end();
                } // Fl_Group* o
                { Fl_Group* o = new Fl_Group(567, 461, 65, 22);
                { uiPixelL = new Fl_Output(582, 461, 50, 22);
                uiPixelL->tooltip("Luminance of image pixel under mouse.");
                uiPixelL->box(FL_NO_BOX);
                uiPixelL->color(FL_BLACK);
                uiPixelL->textsize(10);
                uiPixelL->align(Fl_Align(36));
                } // Fl_Output* uiPixelL
                o->end();
                } // Fl_Group* o
                o->end();
              } // Fl_Group* o
              o->end();
            } // Fl_Group* o
            o->end();
          } // Fl_Group* o
          o->end();
        } // Fl_Group* o
        uiPixelBar->end();
      } // Fl_Group* uiPixelBar
      { uiBottomBar = new Fl_Group(0, 486, 640, 49);
        uiBottomBar->box(FL_ENGRAVED_BOX);
        { uiTimeToolbar = new Fl_Group(0, 486, 640, 49);
          { Fl_Group* o = new Fl_Group(0, 486, 640, 49);
            { mrv::Timeline* o = uiTimeline = new mrv::Timeline(5, 489, 610, 21);
              uiTimeline->tooltip("Timeline.");
              uiTimeline->box(FL_DOWN_BOX);
              uiTimeline->color(FL_BACKGROUND_COLOR);
              uiTimeline->selection_color(FL_BACKGROUND_COLOR);
              uiTimeline->labeltype(FL_NORMAL_LABEL);
              uiTimeline->labelfont(0);
              uiTimeline->labelsize(14);
              uiTimeline->labelcolor(FL_FOREGROUND_COLOR);
              uiTimeline->minimum(1);
              uiTimeline->maximum(50);
              uiTimeline->step(1);
              uiTimeline->value(1);
              uiTimeline->slider_size(1);
              uiTimeline->callback((Fl_Callback*)cb_uiTimeline, (void*)(this));
              uiTimeline->align(Fl_Align(FL_ALIGN_BOTTOM));
              uiTimeline->when(FL_WHEN_CHANGED);
              Fl_Group::current()->resizable(uiTimeline);
              o->main( this );
            } // mrv::Timeline* uiTimeline
            { Fl_Group* o = new Fl_Group(0, 509, 640, 26);
              { Fl_Group* o = new Fl_Group(4, 513, 94, 20);
                { mrv::Timecode* o = uiFrame = new mrv::Timecode(24, 513, 70, 20, "F");
                uiFrame->tooltip("Current frame.");
                uiFrame->box(FL_DOWN_BOX);
                uiFrame->color((Fl_Color)-1733777408);
                uiFrame->selection_color(FL_FOREGROUND_COLOR);
                uiFrame->labeltype(FL_NORMAL_LABEL);
                uiFrame->labelfont(0);
                uiFrame->labelsize(14);
                uiFrame->labelcolor(FL_FOREGROUND_COLOR);
                uiFrame->callback((Fl_Callback*)cb_uiFrame, (void*)(this));
                uiFrame->align(Fl_Align(FL_ALIGN_LEFT));
                uiFrame->when(FL_WHEN_RELEASE);
                o->value(1);
                } // mrv::Timecode* uiFrame
                o->end();
              } // Fl_Group* o
              { Fl_Group* o = new Fl_Group(95, 511, 360, 23);
                { Fl_Group* o = new Fl_Group(95, 512, 215, 22);
                { Fl_Button* o = new Fl_Button(98, 514, 30, 18, "@|<");
                o->tooltip("Go to the beginning of the sequence.");
                o->callback((Fl_Callback*)cb_b, (void*)(this));
                } // Fl_Button* o
                { uiPlayBackwards = new Fl_Button(128, 514, 30, 18, "@<");
                uiPlayBackwards->tooltip("Play sequence backwards.");
                uiPlayBackwards->callback((Fl_Callback*)cb_uiPlayBackwards, (void*)(this));
                } // Fl_Button* uiPlayBackwards
                { Fl_Button* o = new Fl_Button(158, 514, 30, 18, "@<|");
                o->tooltip("Go back one frame.");
                o->callback((Fl_Callback*)cb_c, (void*)(this));
                } // Fl_Button* o
                { Fl_Button* o = new Fl_Button(188, 514, 30, 18, "@||");
                o->tooltip("Stop playback.");
                o->callback((Fl_Callback*)cb_d, (void*)(this));
                } // Fl_Button* o
                { Fl_Button* o = new Fl_Button(218, 514, 30, 18, "@|>");
                o->tooltip("Advance one frame.");
                o->callback((Fl_Callback*)cb_e, (void*)(this));
                } // Fl_Button* o
                { uiPlayForwards = new Fl_Button(248, 514, 30, 18, "@>");
                uiPlayForwards->tooltip("Play sequence forward.");
                uiPlayForwards->callback((Fl_Callback*)cb_uiPlayForwards, (void*)(this));
                } // Fl_Button* uiPlayForwards
                { Fl_Button* o = new Fl_Button(278, 514, 30, 18, "@>|");
                o->tooltip("Go to the end of the sequence.");
                o->callback((Fl_Callback*)cb_f, (void*)(this));
                } // Fl_Button* o
                o->end();
                } // Fl_Group* o
                { Fl_Group* o = new Fl_Group(315, 511, 65, 21);
                { fltk::ValueInput* o = uiFPS = new fltk::ValueInput(344, 513, 35, 18);
                uiFPS->tooltip("Allows you to adjust frame rate playback.");
                uiFPS->box(FL_DOWN_BOX);
                uiFPS->color((Fl_Color)-1733777408);
                uiFPS->selection_color(FL_FOREGROUND_COLOR);
                uiFPS->labeltype(FL_NORMAL_LABEL);
                uiFPS->labelfont(0);
                uiFPS->labelsize(14);
                uiFPS->labelcolor(FL_FOREGROUND_COLOR);
                uiFPS->callback((Fl_Callback*)cb_uiFPS, (void*)(this));
                uiFPS->align(Fl_Align(FL_ALIGN_LEFT));
                uiFPS->when(FL_WHEN_RELEASE);
                o->textcolor( fltk::BLACK );
o->value(24);
                } // fltk::ValueInput* uiFPS
                o->end();
                } // Fl_Group* o
                { Fl_Group* o = new Fl_Group(382, 513, 73, 19);
                { uiVolume = new Fl_Slider(400, 515, 55, 15);
                uiVolume->tooltip("Audio Volume");
                uiVolume->step(0.01);
                uiVolume->value(1);
                uiVolume->callback((Fl_Callback*)cb_uiVolume, (void*)(this));
                uiVolume->align(Fl_Align(FL_ALIGN_LEFT));
                } // Fl_Slider* uiVolume
                o->end();
                } // Fl_Group* o
                o->end();
                Fl_Group::current()->resizable(o);
              } // Fl_Group* o
              { Fl_Group* o = new Fl_Group(455, 509, 180, 24);
                { mrv::Timecode* o = uiStartFrame = new mrv::Timecode(475, 513, 70, 20, "S");
                uiStartFrame->tooltip("Allows you to set starting frame for timeline.");
                uiStartFrame->box(FL_DOWN_BOX);
                uiStartFrame->color((Fl_Color)-1733777408);
                uiStartFrame->selection_color(FL_FOREGROUND_COLOR);
                uiStartFrame->labeltype(FL_NORMAL_LABEL);
                uiStartFrame->labelfont(0);
                uiStartFrame->labelsize(14);
                uiStartFrame->labelcolor(FL_FOREGROUND_COLOR);
                uiStartFrame->callback((Fl_Callback*)cb_uiStartFrame, (void*)(this));
                uiStartFrame->align(Fl_Align(FL_ALIGN_LEFT));
                uiStartFrame->when(FL_WHEN_RELEASE);
                o->value(1);
                } // mrv::Timecode* uiStartFrame
                { mrv::Timecode* o = uiEndFrame = new mrv::Timecode(565, 513, 70, 20, "E");
                uiEndFrame->tooltip("Allows you to set the ending frame for timeline.");
                uiEndFrame->box(FL_DOWN_BOX);
                uiEndFrame->color((Fl_Color)-1733777408);
                uiEndFrame->selection_color(FL_FOREGROUND_COLOR);
                uiEndFrame->labeltype(FL_NORMAL_LABEL);
                uiEndFrame->labelfont(0);
                uiEndFrame->labelsize(14);
                uiEndFrame->labelcolor(FL_FOREGROUND_COLOR);
                uiEndFrame->callback((Fl_Callback*)cb_uiEndFrame, (void*)(this));
                uiEndFrame->align(Fl_Align(FL_ALIGN_LEFT));
                uiEndFrame->when(FL_WHEN_RELEASE);
                o->value(50);
                } // mrv::Timecode* uiEndFrame
                { uiStartButton = new Fl_Button(456, 513, 20, 20, "S");
                uiStartButton->callback((Fl_Callback*)cb_uiStartButton, (void*)(this));
                } // Fl_Button* uiStartButton
                { uiEndButton = new Fl_Button(546, 513, 20, 20, "E");
                uiEndButton->callback((Fl_Callback*)cb_uiEndButton, (void*)(this));
                } // Fl_Button* uiEndButton
                o->end();
              } // Fl_Group* o
              o->end();
            } // Fl_Group* o
            o->end();
          } // Fl_Group* o
          uiTimeToolbar->end();
        } // Fl_Group* uiTimeToolbar
        uiBottomBar->end();
      } // Fl_Group* uiBottomBar
      uiRegion->end();
    } // Fl_Pack* uiRegion
    o->size_range(640, 550);
o->main( this );
    uiMain->end();
    uiMain->resizable(uiMain);
  } // mrv::MainWindow* uiMain
  uiReelWindow = new ReelUI(this);
  uiImageInfo = new ImageInfoUI(this);
  uiColorArea = new ColorAreaUI(this);
  uiGL3dView = new GL3dViewUI(this);
  uiVectorscope = new VectorscopeUI(this);
  uiHistogram = new HistogramUI(this);
  uiPaint = new PaintUI(this);
  if (!uiLog) uiLog   = new LogUI(this);
  if (!uiAbout) uiAbout = new AboutUI(this); // should be static
  
  if (!uiConnection) uiConnection = new ConnectionUI( this );
  
  uiHotkey = new HotkeyUI(this);
  uiICCProfiles = new ICCProfileListUI(this);
  uiEDLWindow = new EDLWindowUI(this);
  
  // read and use preferences
  mrv::Preferences prefs( uiPrefs );
  
  //uiHotkey = new HotkeyUI(this);
  //uiICCProfiles = new ICCProfileListUI(this);
  //uiEDLWindow = new EDLWindowUI(this);
  return uiMain;
}

ViewerUI::ViewerUI() {
  uiMain = make_window();
}

ViewerUI::~ViewerUI() {
  delete uiICCProfiles; uiICCProfiles = NULL;
  delete uiImageInfo; uiImageInfo = NULL;
  delete uiColorArea; uiColorArea = NULL;
  delete uiHistogram; uiHistogram = NULL;
  delete uiVectorscope; uiVectorscope = NULL;
  delete uiGL3dView; uiGL3dView = NULL;
  delete uiAbout; uiAbout = NULL;
  delete uiLog; uiLog = NULL;
  delete uiPaint; uiPaint = NULL;
  delete uiEDLWindow; uiEDLWindow = NULL;
  delete uiMain; uiMain = NULL;
  delete uiReelWindow; uiReelWindow = NULL;
}
